svn diff -r3520 --diff-cmd diff -x -ibw  *.f90 *.F90 > diff_3520_5020
Index: aplbce.f90
===================================================================
47c47
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)  
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)
49c49
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell 
54c54
<         if (m <= 0) CYCLE;
---
>         IF (m == 0) EXIT          ! ... dry column; skip to next flux bc column
58d57
< !$$           if (heat) qhbc = qfbc*eh(m)  
64d62
< !$$        IF( HEAT) QHBC = QFBC* EHOFTP( TFLX( L), P( M), ERFLG)  
70,73d67
< !!$     IF( HEAT) THEN  
< !!$        QHBC2 = QHFBC( L) * UFRAC  
< !!$        RH( M) = RH( M) + UFDT2* ( QHBC2 + QHBC)  
< !!$     ENDIF
80,87d73
< !!$  IF( ERFLG) THEN  
< !!$     WRITE( FUCLOG, 9006) 'EHOFTP interpolation error in APLBCE ', &
< !!$          'Associated heat flux: Specified flux b.c.'
< !!$9006 FORMAT   (TR10,2A,I4)  
< !!$     IERR( 129) = .TRUE.  
< !!$     ERREXE = .TRUE.  
< !!$     RETURN  
< !!$  ENDIF
101c87
<         IF(ifacelbc(ls) == 3) THEN  
---
>         IF(ABS(ifacelbc(ls)) == 3) THEN  
111c97
<         IF(ifacelbc(ls) < 3) THEN  
---
>         IF(ABS(ifacelbc(ls)) < 3) THEN  
137c123
<      IF(mc == 0) CYCLE     ! ... dry column
---
>      IF(mc == 0) CYCLE     ! ... dry column, skip to next river b.c. cell
Index: aplbce_ss_flow.f90
===================================================================
40c40
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)
42c42
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell
47c47
<         if (m <= 0) CYCLE
---
>         IF (m == 0) EXIT          ! ... dry column; skip to next flux bc column
51d50
< !$$           if (heat) qhbc = qfbc*eh(m)
57d55
< !$$        IF( HEAT) QHBC = QFBC* EHOFTP( TFLX( L), P( M), ERFLG)  
63,66d60
< !!$     IF( HEAT) THEN  
< !!$        QHBC2 = QHFBC( L) * UFRAC  
< !!$        RH( M) = RH( M) + UFDT2* ( QHBC2 + QHBC)  
< !!$     ENDIF
86c80
<         IF(ifacelbc(ls) == 3) THEN
---
>         IF(ABS(ifacelbc(ls)) == 3) THEN
96c90
<         IF(ifacelbc(ls) < 3) THEN  
---
>         IF(ABS(ifacelbc(ls)) < 3) THEN  
122c116
<      IF(mc == 0) CYCLE     ! ... dry column
---
>      IF(mc == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
Index: aplbci.f90
===================================================================
248c248
<      m = flux_seg_index(lc)%m     ! ... current flux communication cell
---
>      m = flux_seg_index(lc)%m
251,252c251
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)     
<         ! ... Redirect the flux to the free-surface cell, if necessary
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)     
253a253
>            ! ... Redirect the flux from above to the free-surface cell
258c258
<         if (m <= 0) CYCLE
---
>         IF (m == 0) EXIT          ! ... skip to next flux b.c. cell
274,287d273
<         ELSEIF(ieq == 2) THEN
< !!$           !... ** not available for phast
< !!$           IF(qn.LE.0.) THEN  
< !!$              ! ... outflow
< !!$              !**               dqsbc=den(m)*qn*dc(m)
< !!$              dqhdt = den(m) * qn* cpf  
< !!$           ELSE  
< !!$              ! ... inflow
< !!$              dqsbc = 0.d0  
< !!$              dqhdt = 0.d0  
< !!$           ENDIF
< !!$           va(7, ma) = va(7, ma) - fdtmth* dqhdt  
< !!$           dqsbc = 0.d0  
< !!$           rhs(ma) = rhs(ma) + fdtmth* cc24(m) * dqsbc  
304c290,291
<      IF(frac(m) <= 0._kdp) CYCLE
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next leaky b.c. cell 
>      !$$     IF(frac(m) <= 0._kdp) CYCLE
315a303,318
>            IF(fresur .AND. ifacelbc(ls) == 3) THEN
>               ! ... limit the flow rate for vertical leakage from above
>               qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                    - 0.5_kdp*den(m)*bblbc(ls)))
>               IF(qnp <= qlim) THEN
>                  qm_net = qm_net + denlbc(ls)*qnp
>                  qfbc = qfbc + denlbc(ls)*qn
>                  dqfdp = dqfdp - denlbc(ls)*blbc(ls)
>               ELSEIF(qnp > qlim) THEN
>                  qm_net = qm_net + denlbc(ls)*qlim
>                  qfbc = qfbc + denlbc(ls)*qlim
>                  ! hack for instability from the kink in q vs h relation
>                  IF (steady_flow) dqfdp = dqfdp - denlbc(ls)*blbc(ls)
>                  ! ... add nothing to dqfdp
>               ENDIF
>            ELSE          ! ... x or y face
319a323
>         ENDIF
325,326d328
< !!$     elseif(ieq.eq.2) then
< !!$        !... ** not available for phast
337a340,347
>                  IF(fresur .AND. ifacelbc(ls) == 3) THEN
>                     ! ... limit the flow rate for vertical leakage from above
>                     qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*  &
>                          (zelbc(ls)-0.5_kdp*bblbc(ls)) - 0.5_kdp*den(m)*bblbc(ls)))
>                     qnp = MIN(qnp,qlim)
>                     qm_in = qm_in + denlbc(ls)*qnp
>                     sum_cqm_in = sum_cqm_in + denlbc(ls)*qnp*clbc(ls,is)  
>                  ELSE
340a351
>               ENDIF
411c422
<      IF (m <= 0) CYCLE
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
417c428
<         qnp = qn - brbc(ls)*dp(m)      ! ... with only one flow equation solution qnp = qn always
---
>         qnp = qn - brbc(ls)*dp(m)      ! ... with steady state flow, qnp = qn always
422d432
<            !$$          write(*,*) 1, qfbc, dqfdp, qnp, brbc(ls), p(m)/9807.0_kdp, m, arbc(ls)
431d440
<               !$$              write(*,*) 2, qfbc, dqfdp, qnp, brbc(ls), p(m)/9807.0_kdp, m, qlim
437d445
<               !$$              write(*,*) 3, qfbc, dqfdp, qnp, brbc(ls), p(m)/9807.0_kdp, m, qlim
446,460d453
< !!$     elseif(ieq.eq.2) then
< !!$        !... ** not available for phast
< !!$        if(qnp.le.0.) then  
< !!$           ! ... outflow
< !!$           !**            qsbc=den(m)*qnp*(c(m)+dc(m))
< !!$           qhbc = den(m) * qnp* eh(m)  
< !!$           dqhdt = den(m) * qnp* cpf  
< !!$        else  
< !!$           ! ... inflow
< !!$           if(heat) qhbc = denlbc(l) * qnp* ehoftp(tlbc(l), &
< !!$                p(m), erflg)
< !!$           dqhdt = 0.d0  
< !!$        endif
< !!$        va(7, ma) = va(7, ma) - fdtmth* dqhdt  
< !!$        !            rhs(ma)=rhs(ma)+fdtmth*(qhbc+cc24(m)*qsbc)
542c535
<            ELSE                             ! ... inflow
---
>            ELSE                             ! ... inflow, not allowed
561,567d553
< !!$  if(erflg) then  
< !!$     write(fuclog, 9006) 'ehoftp interpolation error in aplbci ', &
< !!$          'associated heat flux: leakage b.c.'
< !!$     ierr(129) = .true.  
< !!$     errexe = .true.  
< !!$     return  
< !!$  endif
570,635d555
< !!$  do 480 l = 1, naifc  
< !!$     ! ... calculate current aquifer influence function flow rate
< !!$     m = maifc(l)  
< !!$     qn = aaif(l)  
< !!$     qnp = qn + baif(l) * dp(m)  
< !!$     ma = mrno(m)  
< !!$     if(ieq.eq.1) then  
< !!$        if(qnp.le.0) then  
< !!$           ! ... outflow
< !!$           qfbc = den(m) * qn  
< !!$           dqfdp = den(m) * baif(l)  
< !!$           !**            qsbc=qfbc*(c(m)+dc(m))
< !!$           !**            dqsdp=dqfdp*(c(m)+dc(m))
< !!$           qhbc = qfbc* (eh(m) + cpf* dt(m) )  
< !!$           dqhdp = dqfdp* (eh(m) + cpf* dt(m) )  
< !!$        else  
< !!$           ! ... inflow
< !!$           qfbc = denoar(l) * qn  
< !!$           dqfdp = denoar(l) * baif(l)  
< !!$           !               qsbc=qfbc*caif(l)
< !!$           if(heat) ehaif = ehoftp(taif(l), p(m), erflg)  
< !!$           dqsdp = dqfdp* caif(l)  
< !!$           qhbc = qfbc* ehaif  
< !!$           dqhdp = dqfdp* ehaif  
< !!$        endif
< !!$        qsbc = 0.d0  
< !!$        va(7, ma) = va(7, ma) - fdtmth* (dqfdp + cc34(m) * &
< !!$             dqsdp + cc35(m) * dqhdp)
< !!$        rhs(ma) = rhs(ma) + fdtmth* (qfbc + cc34(m) * qsbc + &
< !!$             cc35(m) * qhbc)
< !!$        elseif(ieq.eq.2) then  
< !!$        if(qnp.le.0.) then  
< !!$           ! ... outflow
< !!$           !**            qsbc=den(m)*qnp*(c(m)+dc(m))
< !!$           qhbc = den(m) * qnp* eh(m)  
< !!$           dqhdt = den(m) * qnp* cpf  
< !!$        else  
< !!$           ! ... inflow
< !!$           !               qsbc=denoar(l)*qnp*caif(l)
< !!$           if(heat) qhbc = denoar(l) * qnp* ehoftp(taif(l), &
< !!$                p(m), erflg)
< !!$           dqhdt = 0.d0  
< !!$        endif
< !!$        va(7, ma) = va(7, ma) - fdtmth* dqhdt  
< !!$        !            rhs(ma)=rhs(ma)+fdtmth*(qhbc+cc24(m)*qsbc)
< !!$        elseif(ieq.eq.3) then  
< !!$        if(qnp.le.0.) then  
< !!$           ! ... outflow
< !!$           !**            qsbc=den(m)*qnp*c(m)
< !!$           dqsdc = den(m) * qnp  
< !!$           ! ... inflow
< !!$        else  
< !!$           !               qsbc=denoar(l)*qnp*caif(l)
< !!$           dqsdc = 0.d0  
< !!$        endif
< !!$        va(7, ma) = va(7, ma) - fdtmth* dqsdc  
< !!$        !            rhs(ma)=rhs(ma)+fdtmth*qsbc
< !!$     endif
< !!$480 end do
< !!$  if(erflg) then  
< !!$     write(fuclog, 9006) 'ehoftp interpolation error in aplbci ', &
< !!$          'associated heat flux: aquifer influence function b.c.'
< !!$     ierr(129) = .true.  
< !!$     errexe = .true.  
< !!$     return  
< !!$  endif
638,644d557
< !!$  if(ieq.eq.2) then  
< !!$     do  l = 1, nhcbc  
< !!$        m = mhcbc(l)  
< !!$        ma = mrno(m)  
< !!$        va(7, ma) = va(7, ma) - fdtmth* dqhcdt(l)  
< !!$     end do
< !!$  endif
Index: asmslc.f90
===================================================================
22c22
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
33c33
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
Index: asmslp.f90
===================================================================
23c23
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
34c34
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
Index: asmslp_ss_flow.f90
===================================================================
25c25
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
36c36
<        REAL(KIND=kdp), DIMENSION(:), INTENT(OUT) :: diag
---
>        REAL(KIND=kdp), DIMENSION(:), INTENT(INOUT) :: diag
Index: calc_velocity.f90
===================================================================
113c113
<               IF(ifacefbc(ls) < 3) ufrac = frac(mbc)
---
>               IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(mbc)
115c115
<                  ! ... Redirect the flux to the free-surface cell
---
>                  ! ... Redirect the flux from above to the free-surface cell
120c120
<               if (mbc <= 0) CYCLE
---
>               IF (mbc == 0) EXIT          ! ... skip to next flux b.c. cell
132c132
<                  ELSEIF(ifacefbc(ls) == 3) THEN
---
>                  ELSEIF(ABS(ifacefbc(ls)) == 3) THEN
142c142
<   ! ... Calculate leakage b.c. terms
---
>   ! ... Leakage b.c. terms
153a154,160
>                  IF(fresur .AND. ifacelbc(ls) == 3) THEN
>                     ! ... Limit the flow rate for vertical leakage from above
>                     qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                          - 0.5_kdp*den(mbc)*bblbc(ls)))
>                     qn = MIN(qn,qlim)
>                     qface = denlbc(ls)*qn
>                  ELSE
155a163
>               ENDIF
161c169
<                  ELSEIF(ifacelbc(ls) == 3) THEN
---
>                  ELSEIF(ABS(ifacelbc(ls)) == 3) THEN
174c182
<      IF(m == 0) CYCLE              ! ... empty cell
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
209c217
<               ELSE                            ! ... Inflow
---
>               ELSE                            ! ... Inflow, not allowed
Index: coeff.f90
===================================================================
167c167
<                           tsx(m)=tsx(m)+(tdx+dm)*uden*ufrac*updydz/udx
---
>                           tsx(m)=tsx(m)+(tdx+tort(ipmz)*dm)*uden*ufrac*updydz/udx
219c219
<                           tsy(m)=tsy(m)+(tdy+dm)*uden*ufrac*updxdz/udy
---
>                           tsy(m)=tsy(m)+(tdy+tort(ipmz)*dm)*uden*ufrac*updxdz/udy
269c269
<                           tsz(m)=tsz(m)+(tdz+dm)*uden*updxdy/udz
---
>                           tsz(m)=tsz(m)+(tdz+tort(ipmz)*dm)*uden*updxdy/udz
321c321
<                        tsx(m)=tsx(m)+(tdx+dm)*uden*ufrac*updydz/udx
---
>                        tsx(m)=tsx(m)+(tdx+tort(ipmz)*dm)*uden*ufrac*updydz/udx
360c360
<                        tsz(m)=tsz(m)+(tdz+dm)*uden*updxdy/udz
---
>                        tsz(m)=tsz(m)+(tdz+tort(ipmz)*dm)*uden*updxdy/udz
Index: error3.f90
===================================================================
66a67,74
>   ! ... Leakage b.c.
>   IF(rdlbc .AND. fresur) THEN
>      DO  ls=1,nlbc_seg
>         if(ifacelbc(ls) == 3) then
>            IF(philbc(ls) < gz*zelbc(ls)) ierr(73)=.TRUE.
>         end if
>      END DO
>   END IF
108a117
>   IF(pri_zf_heads > 0._kdp .AND. pri_zf_heads < udeltim) warnflag = warnflag + 1
Index: errprt.f90
===================================================================
132,141d131
<   IF(ierr(47)) THEN
<      erline='47  - READ2 -  LLBC is too small, '//  &
<           'too many leakage b. c. cells:param3.inc'
<      CALL errprt_c(erline)
<   END IF
<   IF(ierr(50)) THEN
<      erline='50  - READ2 - LWEL is too small, too many '//  &
<           'wells defined:param4.inc'
<      CALL errprt_c(erline)
<   END IF
214a205,209
>      CALL errprt_c(erline)
>   END IF
>   IF(ierr(73)) THEN
>      erline='73  - READ3 - Leakage head set below external '//  &
>           'elevation of leaky boundary'
Index: hdf_f.f90
===================================================================
140c140
<         time_step_fscalar_count = time_step_fscalar_count + 3
---
>         time_step_fscalar_count = time_step_fscalar_count + 4
Index: init1.f90
===================================================================
31c31
<        ibc(nxyz), pv0(nxyz),  &
---
>        ibc(nxyz), pv0(nxyz), volume(nxyz), &
40a41
>   volume = 0
Index: init2_1.f90
===================================================================
36a37
>   CHARACTER(LEN=130) :: logline1, logline2
42c43,44
<   INTEGER :: a_err, da_err, i, ic, imm, imod, ipmz, iis, iwel, j, jc, k, k1, k2, kf, &
---
>   INTEGER :: a_err, da_err, i, ic, icol, imm, imod, ipmz, iis, iwel, j, jc, jcol,  &
>        k, k1, k2, kcol, kf, &
662,663c664
<         ! ... This loop expects all segments attached to a given cell to be 
<         ! ...      contiguous
---
>         ! ... This loop expects all segments attached to a given cell to be contiguous
702,703c703
<         ! ... This loop expects all segments attached to a given cell to be 
<         ! ...      contiguous
---
>         ! ... This loop expects all segments attached to a given cell to be contiguous
1301c1301
<   ALLOCATE (mfsbc(nxy), hdprnt(nxyz), wt_elev(nxy),  &
---
>   ALLOCATE (mfsbc(nxy), print_dry_col(nxy), hdprnt(nxyz), wt_elev(nxy),  &
1374,1375c1374,1375
<                  z0=z(k-1)
<                  z1=z(k)
---
>                  zm1=z(k-1)
>                  z0=z(k)
1450a1451
>   print_dry_col = .FALSE.
1452,1457c1453,1462
<      m1 = nxyz-nxy+mt
< 750  IF(frac(m1) > 0._kdp) go to 760  
<      m1 = m1-nxy
<      IF(m1 > 0) go to 750
<      m1 = 0
< 760  mfsbc(mt) = m1
---
>      mfsbc(mt) = 0
>      DO k=nz,1,-1
>         m1 = (k-1)*nxy + mt
>         IF (ibc(m1) >= 0) THEN
>            IF(frac(m1) > 0._kdp) THEN
>               mfsbc(mt) = m1
>               EXIT
>            END IF
>         END IF
>      END DO
1461,1462c1466,1479
<      IF(mfsbc(mt) /= 0) all_dry = .FALSE.
<      IF(mfsbc(mt) == 0) some_dry = .TRUE.
---
>      IF(m1 == 0) THEN
>         some_dry = .TRUE.
>         CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>         WRITE(logline1,'(a)')  'WARNING: A column of cells is dry in init2_1'
>         CALL screenprt_c(logline1)
>         CALL logprt_c(logline1)
>         WRITE(logline1,'(tr5,a,i6,a,i5,a,i5,i5)')   &
>              'Cell column:', mt,' (i,j):', icol, ',', jcol
>         CALL screenprt_c(logline1)
>         CALL logprt_c(logline1)
>         print_dry_col(mt) = .TRUE.
>      ELSE
>         all_dry = .FALSE.
>      END IF
1466c1483
<      CALL warnprt_c('One or more columns are dry.')
---
>      CALL warnprt_c('One or more cell columns are dry.')
1473c1490
<         ! excluded cell values
---
>         ! ... excluded cell values
1482c1499
<         ! dry cell values
---
>         ! ... dry cell values
1547a1565
>   CALL calc_volume
Index: init2_2.f90
===================================================================
142a143
>   ntprzf_heads = 0
Index: init2_post_ss.f90
===================================================================
214a215
>   dp = 0._kdp           ! ... dp=0 for steady state flow to transport
Index: init3.f90
===================================================================
26a27
>   CHARACTER(LEN=130) :: logline1
29c30
<   INTEGER :: da_err, ic, imod, iis, iwel, k, l, ls, m, m1, mt
---
>   INTEGER :: da_err, ic, icol, imod, iis, iwel, jcol, k, l, ls, m, m1, mt, kcol
186a188
>   ! ... Allows for resaturation of cell columns by specified head (pressure) b.c.
188,193c190,199
<      m1 = nxyz-nxy+mt
< 750  IF(frac(m1) > 0._kdp) go to 760  
<      m1 = m1-nxy
<      IF(m1 > 0) go to 750
<      m1 = 0
< 760  mfsbc(mt) = m1
---
>      mfsbc(mt) = 0
>      DO k=nz,1,-1
>         m1 = (k-1)*nxy + mt
>         IF (ibc(m1) >= 0) THEN
>            IF(frac(m1) > 0._kdp) THEN
>               mfsbc(mt) = m1
>               EXIT
>            END IF
>         END IF
>      END DO
196a203,211
>      IF(m1 == 0 .AND. .NOT.print_dry_col(mt)) THEN
>         CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>         WRITE(logline1,'(a/tr5,a,i6,a,i5,a,i5)')   &
>              'WARNING: A column of cells is dry in init3',  &
>              'Cell column:', mt,' (i,j):', icol, ',', jcol
>         CALL screenprt_c(logline1)
>         CALL logprt_c(logline1)
>         print_dry_col(mt) = .TRUE.
>      END IF
xo234,235c249
<      ! ... Load the associated concentrations
<      IF(solute) THEN
---
>      IF(solute) THEN               ! ... Load the associated concentrations

Property changes on: interpolate_mod.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: ldchar_bc.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: ld_seg_mod.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: media_hdf.f90
===================================================================
20d19
< 
43a43
>      REAL(KIND=kdp) :: tort        ! tort
52a53,54
>   ! ... set string for use with rcs ident command
>   CHARACTER(LEN=80) :: ident_string='$Id: media_hdf.f90,v 1.3 2010/03/05 21:51:23 klkipp Exp $'
62,63c64,68
<        0._kdp, 0._kdp, 0._kdp,0._kdp, 0._kdp, 0._kdp)
< 
---
>        0._kdp, 0._kdp, 0._kdp,0._kdp, 0._kdp, 0._kdp, 0._kdp)
> !
> ! Calculate volume-weighted properties for each cell
> ! Even though some properties are weighted by facial area for conductances
> !
108a114,115
>                     cell_props(m)%tort      = cell_props(m)%tort      + &
>                         udxyz * tort(ipmz)    
127a135
>            cell_props(m)%tort      = cell_props(m)%tort / cell_props(m)%volume
199a208,214
> 
>      ! Tortuosity
>      DO m = 1, nxyz
>         aprnt(m) = cell_props(m)%tort
>      END DO
>      name = 'Tortuosity (cell vol avg)'
>      CALL prntar_hdf(aprnt, full, conv, name)     
208a224,336
> 
> SUBROUTINE calc_volume
> ! Logic for volume weighting copied from init2_1
>   USE machine_constants, ONLY: kdp
>   USE mcb
>   USE mcb2
>   USE mcc
>   USE mcg
>   USE mcm
>   USE mcn
>   USE mcp
>   USE mcs
>   USE mcs2
>   USE mcv
>   USE mcw
>   USE mg2
>   USE phys_const
>   USE hdf_media
>   IMPLICIT NONE
>   !
> 
>   INTRINSIC index
>   INTERFACE
>      FUNCTION nintrp(xarg,nx,xs,erflg)
>        USE machine_constants, ONLY: kdp
>        REAL(KIND=kdp), INTENT(IN) :: xarg
>        INTEGER, INTENT(IN) :: nx
>        REAL(KIND=kdp), DIMENSION(:), INTENT(IN) :: xs
>        LOGICAL, INTENT(INOUT) :: erflg
>        INTEGER :: nintrp
>      END FUNCTION nintrp
>   END INTERFACE
>   TYPE :: cell_properties
>      LOGICAL        :: active
>      INTEGER        :: subdomains
>      REAL(KIND=kdp) :: volume
>      REAL(KIND=kdp) :: kxx         ! kxx
>      REAL(KIND=kdp) :: kyy         ! kyy
>      REAL(KIND=kdp) :: kzz         ! kzz
>      REAL(KIND=kdp) :: poros       ! poros
>      REAL(KIND=kdp) :: storage     ! abpm
>      REAL(KIND=kdp) :: alphl       ! alphl
>      REAL(KIND=kdp) :: alphth      ! alphth
>      REAL(KIND=kdp) :: alphtv      ! alphtv
>   END TYPE cell_properties
> 
>   REAL(KIND=kdp) :: udz, udy, udydz, udx, udxdy, udxdz, udxyz
>   INTEGER :: a_err, da_err, i, j, k, m, imm, ipmz
>   INTEGER, DIMENSION(8) :: mm
>   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: aprnt, full
>   REAL(KIND=kdp) :: conv
>   CHARACTER (LEN=119) :: name
>   TYPE(cell_properties), DIMENSION(:), ALLOCATABLE :: cell_props
>   !     ------------------------------------------------------------------
>   
>   IF (.NOT. solute) RETURN
> !  ALLOCATE (volume(nxyz), &
> !       stat = a_err)
> !  IF (a_err /= 0) THEN  
> !     PRINT *, "Array allocation failed: calc_porsosity_volume, volume"  
> !     STOP  
> !  ENDIF 
>   volume = 0
>   ALLOCATE (cell_props(nxyz), &
>        stat = a_err)
>   IF (a_err /= 0) THEN  
>      PRINT *, "Array allocation failed: calc_porsosity_volume, cell_props"  
>      STOP  
>   ENDIF
> 
>   cell_props = cell_properties(.FALSE., 0, 0._kdp, 0._kdp, 0._kdp, &
>        0._kdp, 0._kdp, 0._kdp,0._kdp, 0._kdp, 0._kdp)
> 
>   DO ipmz = 1, npmz  
>      DO k = k1z(ipmz), k2z(ipmz) - 1  
>         DO j = j1z(ipmz), j2z(ipmz) - 1  
>            udy = y(j + 1) - y(j)  
>            DO i = i1z(ipmz), i2z(ipmz) - 1  
>               udx = x(i + 1) - x(i)  
>               udxdy = udx*udy*.25  
>               mm(1) = cellno(i, j, k)  
>               mm(2) = mm(1) + 1  
>               mm(3) = mm(2) + nx  
>               mm(4) = mm(1) + nx  
>               mm(5) = mm(1) + nxy  
>               mm(6) = mm(2) + nxy  
>               mm(7) = mm(3) + nxy  
>               mm(8) = mm(4) + nxy  
>               udxyz = .5*udxdy*(z(k + 1) - z(k) )  
>               DO imm = 1, 8  
>                  m = mm(imm)  
>                  cell_props(m)%active = .TRUE.
>                  cell_props(m)%volume     = cell_props(m)%volume     + udxyz
>               END DO
>            END DO
>         END DO
>     END DO
>   END DO
>   
>   ! Volume weight values
>   DO m = 1, nxyz
>      IF (cell_props(m)%active) THEN
>         volume(m) = cell_props(m)%volume
>      ENDIF
>   END DO
> 
>   DEALLOCATE (cell_props, &
>        stat = da_err)
>   IF (da_err /= 0) THEN  
>      PRINT *, "Array deallocation failed: calc_volume, cell_props"  
>      STOP  
>   ENDIF
> END SUBROUTINE calc_volume

Property changes on: media_hdf.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: modules.f90
===================================================================
10c10
<        fuzf=36, fuzf_tsv=37, fuwt=38, fupmp3=39
---
>        fuzf=36, fuzf_tsv=37, fuwt=38, fupmp3=39, fuzf_heads=40
80a81
>   LOGICAL, DIMENSION(:), ALLOCATABLE :: print_dry_col
126a128,129
>   CHARACTER(LEN=140), DIMENSION(:), ALLOCATABLE :: zone_filename_heads
>   LOGICAL, DIMENSION(:), ALLOCATABLE :: zone_write_heads
154a158,161
>   ! print control flags for zone_flow heads + print_zone_flows_heads    
>   REAL (KIND=kdp) :: pri_zf_heads, timprzf_heads
>   LOGICAL :: przf_heads=.false.
>   INTEGER :: ntprzf_heads
264c271
<        xele, yele, zele, x_face, y_face, z_face, pv0
---
>        xele, yele, zele, x_face, y_face, z_face, pv0, volume
286,287c293,294
<   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: abpm, alphl, alphth, alphtv, pmchv, pmcv, pmhv,  &
<        pv, pvk, &
---
>   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: abpm, alphl, alphth, alphtv, tort, pmchv, pmcv, &
>        pmhv, pv, pvk, &
348a356,358
>   !INTEGER :: solid_units(6)
>   INTEGER :: exchange_units, surface_units, ssassemblage_units, &
>   		ppassemblage_units, gasphase_units, kinetics_units
Index: print_control_mod.f90
===================================================================
26c26
<        print_zone_flows_tsv, print_wells, &
---
>        print_zone_flows_tsv, print_zone_flows_heads, print_wells, &
63a64
>     CALL pc_init(print_zone_flows_heads, .FALSE., "print_zone_flows_heads")
135a137
>     CALL pc_set_print_flag(print_zone_flows_heads, utime, itime, utimchg)
224a227,231
>     przf_heads = print_zone_flows_heads%print_flag
>     pri_zf_heads = print_zone_flows_heads%print_interval
>     timprzf_heads = print_zone_flows_heads%print_time
>     ntprzf_heads = print_zone_flows_heads%count_prints 
>     
339a347,351
>     print_zone_flows_heads%print_flag = przf_heads
>     print_zone_flows_heads%print_interval = pri_zf_heads
>     print_zone_flows_heads%print_time = timprzf_heads
>     print_zone_flows_heads%count_prints = ntprzf_heads    
> 
437a450
>     CALL pc_set_print_time(print_zone_flows_heads, utime)
482a496
>     CALL pc_update_print_time(print_zone_flows_heads, utime)
528a543
>     CALL pc_dump(print_zone_flows_heads)
Index: read2.f90
===================================================================
62c62,63
<   ALLOCATE (uzelb(nxyz), uklb(nxyz), ubblb(nxyz),  &
---
>   !ALLOCATE (uzelb(nxyz), uklb(nxyz), ubblb(nxyz),  &
>   ALLOCATE ( &
243c244
<   ALLOCATE (abpm(npmz), alphl(npmz), alphth(npmz), alphtv(npmz), poros(npmz), &
---
>   ALLOCATE (abpm(npmz), alphl(npmz), alphth(npmz), alphtv(npmz), tort(npmz), poros(npmz), &
295,296c296,298
<      IF (print_rde) WRITE(furde, 8008) '(alphl(i),alphth(i),alphtv(npmz),i=1,npmz)', '[2.11]', &
<           (alphl(i),alphth(i),alphtv(npmz),i=1,npmz)
---
>      READ(fuins,*) (tort(i), i=1,npmz)
>      IF (print_rde) WRITE(furde, 8008) '(alphl(i),alphth(i),alphtv(i),tort(i),i=1,npmz)', '[2.11]', &
>           (alphl(i),alphth(i),alphtv(i),tort(i),i=1,npmz)
497c499
<         ifc = uiface(ls)
---
>         ifc = ABS(uiface(ls))
563c565
<         ifc = uiface(ls)
---
>         ifc = ABS(uiface(ls))
811a814,818
>      READ(fuins, *) exchange_units, surface_units, ssassemblage_units, &
>           ppassemblage_units, gasphase_units, kinetics_units 
>      IF (print_rde) WRITE(furde, '(a, 6i5)') 'solid_units,[2.21.7a] ex, surf, ss, pp, gas, kin ', &
>           exchange_units, surface_units, ssassemblage_units, &
>           ppassemblage_units, gasphase_units, kinetics_units
925a933,934
>           zone_filename_heads(num_flo_zones),  &
>           zone_write_heads(num_flo_zones), &
931c940
<      IF(fresur .AND. (nfbc > 0 .OR. nrbc > 0)) THEN
---
>      !IF(fresur .AND. (nfbc > 0 .OR. nrbc > 0)) THEN
941c950
<      END IF
---
>      !END IF
953c962,967
<         IF(fresur .AND. (nfbc > 0 .OR. nrbc > 0)) THEN
---
>         READ(fuins,*) zone_write_heads(izn)
>         if(zone_write_heads(izn)) READ(fuins,'(a)') zone_filename_heads(izn)
>         IF (print_rde) WRITE(furde,'(tr5,l2,a)') zone_write_heads(izn), zone_filename_heads(izn)
>         zone_filename_heads(izn) = ADJUSTL(zone_filename_heads(izn))
> 
>         IF((fresur .AND. (nfbc > 0 .OR. nrbc > 0)) .OR. zone_write_heads(izn)) THEN
Index: read3.f90
===================================================================
281,282c281,283
<      READ(fuins,*) pri_zf, pri_zf_tsv
<      IF (print_rde) WRITE(furde,8111) 'pri_zf, pri_zf_tsv[3.8.2.2]', pri_zf, pri_zf_tsv
---
>      READ(fuins,*) pri_zf, pri_zf_tsv, pri_zf_heads
>      IF (print_rde) WRITE(furde,8111) 'pri_zf, pri_zf_tsv, pri_zf_heads[3.8.2.2]', &
>         pri_zf, pri_zf_tsv, pri_zf_heads
285a287
>      pri_zf_heads = -pri_zf_heads

Property changes on: rewi_mod.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: rhsn.f90
===================================================================
220c220
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)
222c222
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell
227c227
<         IF(m == 0) CYCLE     ! ... dry column
---
>         IF(m == 0) EXIT     ! ... dry column, skip to next flux b.c. cell
293a294,310
>   IF(fresur) THEN
>      DO lc=1,nlbc
>         ! ... Update the indices locating the cells communicating with leaky layer
>         mc0 = leak_seg_index(lc)%m
>         lc0 = MOD(mc0,nxy)
>         IF(lc0 == 0) lc0 = nxy
>         mfs = mfsbc(lc0)    ! ... currrent f.s. cell in column lc0
>         !$$     leak_seg_index(lc)%m = MIN(mfs,mrbc_bot(lc))
>         DO ls=leak_seg_index(lc)%seg_first,leak_seg_index(lc)%seg_last
>            IF(ifacelbc(ls) == 3) THEN
>               leak_seg_index(lc)%m = mfs            ! ... communicate with f.s. cell always
>               !$$        mrbc(ls) = MIN(mfs,mrseg_bot(ls))    ! ... currrent leakage segment cell 
>               mlbc(ls) = leak_seg_index(lc)%m     ! ... currrent leakage segment cell for aquifer head
>            END IF                            ! ... now the same as communication cell
>         END DO
>      END DO
>   END IF
295c312
<      m = leak_seg_index(lc)%m
---
>      m = leak_seg_index(lc)%m          ! ... current communicating cell 
307a325,330
>            IF(fresur .AND. ifacelbc(ls) == 3) THEN
>               ! ... Limit the flow rate for unconfined z-face leakage from above
>               qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                    - 0.5_kdp*den(m)*bblbc(ls)))
>               qn = MIN(qn,qlim)
>            END IF
329a353,358
>               IF(fresur .AND. ifacelbc(ls) == 3) THEN
>                  ! ... limit the flow rate for unconfined z-face leakage from above
>                  qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*  &
>                       (zelbc(ls)-0.5_kdp*bblbc(ls)) - 0.5_kdp*den(m)*bblbc(ls)))
>                  qn = MIN(qn,qlim)
>               END IF
380,381c409,410
<      IF(m == 0) CYCLE              ! ... empty column 
<      ! ... Calculate current net aquifer leakage flow rate
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
>      ! ... Calculate current net river leakage flow rate
469d497
< !!$        STOTHP=STOTHP-0.5*QHDBC(LC)
475c503
<         ELSE                        ! ... Inflow
---
>         ELSE                        ! ... Inflow, none allowed
479d506
< !!$        STOTHI=STOTHI+0.5*QHDBC(LC)
489,493d515
< !!$     IF(HEAT) THEN
< !!$       RH(M)=RH(M)+UFDT0*QHDBC(LC)
< !!$       SHRB(LC)=QHDBC(LC)
< !!$       STHDBC=STHDBC+0.5*QHDBC(LC)
< !!$     ENDIF
504,547d525
< !!$  DO  l=1,naifc
< !!$     m=maifc(l)
< !!$     IF(qfaif(l) <= 0.) THEN
< !!$        ! ... Outflow
< !!$        stotfp=stotfp-0.5*qfaif(l)
< !!$        stothp=stothp-0.5*qhaif(l)
< !!$        !...            STOTSP=STOTSP-0.5*QSAIF(L)
< !!$        sfvaif(l)=qfaif(l)/den(m)
< !!$        ! ... Inflow
< !!$     ELSE
< !!$        stotfi=stotfi+0.5*qfaif(l)
< !!$        stothi=stothi+0.5*qhaif(l)
< !!$        !...            STOTSI=STOTSI+0.5*QSAIF(L)
< !!$        sfvaif(l)=qfaif(l)/denoar(l)
< !!$     END IF
< !!$     rf(m)=rf(m)+ufdt0*qfaif(l)
< !!$     sfaif(l)=qfaif(l)
< !!$     stfaif=stfaif+0.5*qfaif(l)
< !!$     IF(heat) THEN
< !!$        rh(m)=rh(m)+ufdt0*qhaif(l)
< !!$        shaif(l)=qhaif(l)
< !!$        sthaif=sthaif+0.5*qhaif(l)
< !!$     END IF
< !!$     IF(solute) THEN
< !!$        !...            RS(M)=RS(M)+UFDT0*QSAIF(L)
< !!$        stsaif(l)=qsaif(l)
< !!$        !            STSAIF=STSAIF+0.5*QSAIF(L)
< !!$     END IF
< !!$  END DO
< !!$  IF(heat) THEN
< !!$     !... *** not implemented in PHAST
< !!$     ! ... Calculate heat conduction b.c. and apply to r.h.s.
< !!$     ! ...      Calculate step total flow rates
< !!$     DO  l=1,nhcbc
< !!$        m=mhcbc(l)
< !!$        rh(m)=rh(m)+ufdt0*qhcbc(l)
< !!$        IF(qhcbc(l) <= 0.) THEN
< !!$           stothp=stothp-0.5*qhcbc(l)
< !!$        ELSE
< !!$           stothi=stothi+0.5*qhcbc(l)
< !!$        END IF
< !!$        sthhcb=sthhcb+0.5*qhcbc(l)
< !!$     END DO
< !!$  END IF
Index: rhsn_ss_flow.f90
===================================================================
129c129
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)  
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)  
131c131
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell
136c136
<         IF(m == 0) CYCLE     ! ... dry column        
---
>         IF(m == 0) EXIT     ! ... dry column, skip to next flux b.c. cell
153a154,170
>   IF(fresur) THEN
>      DO lc=1,nlbc
>         ! ... Update the indices locating the cells communicating with leaky layer
>         mc0 = leak_seg_index(lc)%m
>         lc0 = MOD(mc0,nxy)
>         IF(lc0 == 0) lc0 = nxy
>         mfs = mfsbc(lc0)    ! ... currrent f.s. cell in column lc0
>         !$$     leak_seg_index(lc)%m = MIN(mfs,mrbc_bot(lc))
>         DO ls=leak_seg_index(lc)%seg_first,leak_seg_index(lc)%seg_last
>            IF(ifacelbc(ls) == 3) THEN
>               leak_seg_index(lc)%m = mfs            ! ... communicate with f.s. cell always
>               !$$        mrbc(ls) = MIN(mfs,mrseg_bot(ls))    ! ... currrent leakage segment cell 
>               mlbc(ls) = leak_seg_index(lc)%m     ! ... currrent leakage segment cell for aquifer head
>            END IF                            ! ... now the same as communication cell
>         END DO
>      END DO
>   END IF
xo167a185,190
>            IF(fresur .AND. ifacelbc(ls) == 3) THEN
>               ! ... Limit the flow rate for unconfined z-face leakage from above
>               qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                    - 0.5_kdp*den(m)*bblbc(ls)))
>               qn = MIN(qn,qlim)
>            END IF
189c212
< !     river_seg_index(lc)%m = MIN(mfs,mrbc_bot(lc))
---
>      !$$     river_seg_index(lc)%m = MIN(mfs,mrbc_bot(lc))
192c215
< !        mrbc(ls) = MIN(mfs,mrseg_bot(ls))    ! ... currrent river segment cell for aquifer head
---
>         !$$        mrbc(ls) = MIN(mfs,mrseg_bot(ls))    ! ... currrent river segment cell for aquifer head
202,203c225,226
<      IF(m == 0) CYCLE              ! ... empty column 
<      ! ... Calculate current net aquifer leakage flow rate
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
>      ! ... Calculate current net river leakage flow rate
229d251
<  
250c272
<      IF(m == 0) CYCLE              ! ... empty column 
---
>      IF(m == 0) CYCLE          ! ... dry column
257c279
<         ELSE                             ! ... Inflow
---
>         ELSE                             ! ... Inflow, none allowed
271,287d292
< !!$  DO  l=1,naifc
< !!$     m=maifc(l)
< !!$     IF(qfaif(l) <= 0.) THEN
< !!$        ! ... Outflow
< !!$        stotfp=stotfp-0.5*qfaif(l)
< !!$        stothp=stothp-0.5*qhaif(l)
< !!$        sfvaif(l)=qfaif(l)/den(m)
< !!$     ELSE
< !!$        ! ... Inflow
< !!$        stotfi=stotfi+0.5*qfaif(l)
< !!$        stothi=stothi+0.5*qhaif(l)
< !!$        sfvaif(l)=qfaif(l)/denoar(l)
< !!$     END IF
< !!$     rf(m)=rf(m)+ufdt0*qfaif(l)
< !!$     sfaif(l)=qfaif(l)
< !!$     stfaif=stfaif+0.5*qfaif(l)
< !!$  END DO
Index: scale_jds.f90
===================================================================
26c26
<   CHARACTER(LEN=80) :: ident_string='$RCSfile: scale_jds.f90,v $//$Revision: 1.1 $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: scale_jds.f90,v 1.2 2010/03/05 21:51:23 klkipp Exp $'
146c146
<   CHARACTER(LEN=80) :: ident_string='$RCSfile: scale_jds.f90,v $//$Revision: 1.1 $'
---
>   CHARACTER(LEN=80) :: ident_string='$RCSfile: scale_jds.f90,v $//$Revision: 1.2 $'

Property changes on: scale_jds.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: sumcal1.f90
===================================================================
628c628
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)  
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)  
630c630
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell
635c635
<         if (m <= 0) CYCLE
---
>         IF (m == 0) EXIT          ! ... dry column, skip to next flux b.c. cell
687d686
< !!$     CCHFB(L)=CCHFB(L)+0.5*SHFB(L)*DELTIM
731a731,736
>            IF(fresur .AND. ifacelbc(ls) == 3) THEN
>               ! ... Limit the flow rate for z-face unconfined leakage from above
>               qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                    - 0.5_kdp*den(m)*bblbc(ls)))
>               qnp = MIN(qnp,qlim)
>            END IF
752a758,763
>               IF(fresur .AND. ifacelbc(ls) == 3) THEN
>                  ! ... limit the flow rate for unconfined z-face leakage from above
>                  qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*  &
>                       (zelbc(ls)-0.5_kdp*bblbc(ls)) - 0.5_kdp*den(m)*bblbc(ls)))
>                  qnp = MIN(qnp,qlim)
>               END IF
786c797
<   ! ... Do not update the indices connecting river to aquifer yet!
---
>   ! ... Do not update the indices connecting leakage to aquifer yet!
809c820
<      IF(m == 0) CYCLE
---
>      IF(m == 0) CYCLE              ! ... dry column, skip to next river b.c. cell 
Index: sumcal2.f90
===================================================================
18a19
>   CHARACTER(LEN=130) :: logline1
23,24c24,25
<   INTEGER :: da_err, i, imod, iwel, j, k, kfs, l, lc, l1, ls, m, m0, m1,  &
<        m1kp, mfs, mt
---
>   INTEGER :: da_err, i, icol, imod, iwel, j, jcol, k, kcol, kfs, l, lc, l1, ls,  &
>        m, m0, m1, m1kp, mfs, mt
26,27d26
<   CHARACTER(LEN=130) :: logline
< !!$  REAL(KIND=kdp), DIMENSION(nxy) :: fracn
347d345
<         m0 = mfsbc(mt)
349,354c347,352
<         m1=nxyz-nxy+mt
< 200     IF(frac(m1) > 0._kdp) GO TO 210
<         m1=m1-nxy
<         IF(m1 > 0) GO TO 200
<         m1=0
< 210     IF(ABS(m1 - m0) > nxy) ierrw = .TRUE.
---
>         m0 = mfsbc(mt)
>         mfsbc(mt) = 0
>         DO k=nz,1,-1
>            m1 = (k-1)*nxy + mt
>            IF (ibc(m1) >= 0) THEN
>               IF(frac(m1) > 0._kdp) THEN
355a354,357
>                  EXIT
>               END IF
>            END IF
>         END DO
359,363c361,382
<      END DO
<      IF(ierrw) then
<         WRITE(logline,*) 'WARNING: Free surface has moved more than one layer of cells'//  &
<           ' in one or more cell columns'
<         call screenprt_c(logline)
---
>         IF(ABS(m1 - m0) > nxy) THEN
>            CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>            WRITE(logline1,'(a)')  &
>                 'WARNING: Free surface has moved more than one layer of cells in sumcal2'
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>            WRITE(logline1,'(tr5,a,i6,a,i5,a,i5)')   &
>                 'Cell column:', mt,' (i,j):', icol, ',', jcol
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>         END IF
>         IF(m1 == 0 .AND. .NOT.print_dry_col(mt)) THEN
>            CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>            WRITE(logline1,'(a)')  &
>                 'WARNING: A column of cells has gone dry in sumcal2'
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>            WRITE(logline1,'(tr5,a,i6,a,i5,a,i5)')  &
>                 'Cell column:', mt,' (i,j):', icol, ',', jcol
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>            print_dry_col(mt) = .TRUE.
364a384
>      END DO
Index: sumcal_ss_flow.f90
===================================================================
27,28d26
<   !  EXTERNAL ehoftp, viscos
<   !  REAL(kind=kdp) :: ehoftp, viscos
36,37c34,35
<   INTEGER :: a_err, da_err, i, imod, iwel, j, k, kfs, l, l1, lc, ls, m, m0, m1, m1kp, mfs,  &
<        mpmax, mt
---
>   INTEGER :: a_err, da_err, i, icol, imod, iwel, j, jcol, k, kfs, kcol,  &
>        l, l1, lc, ls, m, m0, m1, m1kp, mfs, mpmax, mt
433d430
<         m0 = mfsbc(mt)
435,440c432,437
<         m1=nxyz-nxy+mt
< 200     IF(frac(m1) > 0._kdp) GO TO 210
<         m1=m1-nxy
<         IF(m1 > 0) GO TO 200
<         m1=0
< 210     IF(ABS(m1 - m0) > nxy) ierrw = .TRUE.
---
>         m0 = mfsbc(mt)
>         mfsbc(mt) = 0
>         DO k=nz,1,-1
>            m1 = (k-1)*nxy + mt
>            IF (ibc(m1) >= 0) THEN
>               IF(frac(m1) > 0._kdp) THEN
441a439,442
>                  EXIT
>               END IF
>            END IF
>         END DO
445,448c446,453
<      END DO
<      IF(ierrw) THEN
<         WRITE(logline1,*) 'WARNING: Free surface has moved more than one layer of cells'//  &
<              ' in one or more cell columns'
---
>         IF(ABS(m1 - m0) > nxy) THEN
>            CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>            WRITE(logline1,'(a)') &
>                 'WARNING: Free surface has moved more than one layer of cells in sumcal_ss_flow'
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>            WRITE(logline1,'(tr5,a,i6,a,i5,a,i5)')   &
>                 'Cell column:', mt,' (i,j):', icol, ',', jcol
449a455
>            CALL logprt_c(logline1)                      
450a457,468
>         IF(m1 == 0 .AND. .NOT.print_dry_col(mt)) THEN
>            CALL mtoijk(mt,icol,jcol,kcol,nx,ny)
>            WRITE(logline1,'(a)') 'WARNING: A column of cells has gone dry in sumcal_ss_flow'
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)
>            WRITE(logline1,'(tr5,a,i6,a,i5,a,i5)')   &
>                 'Cell column:', mt,' (i,j):', icol, ',', jcol
>            CALL screenprt_c(logline1)
>            CALL logprt_c(logline1)           
>            print_dry_col(mt) = .TRUE.
>         END IF
>      END DO
559c577
<         IF(ifacefbc(ls) < 3) ufrac = frac(m)  
---
>         IF(ABS(ifacefbc(ls)) < 3) ufrac = frac(m)  
561c579
<            ! ... Redirect the flux to the free-surface cell
---
>            ! ... Redirect the flux from above to the free-surface cell
566c584
<         if (m <= 0) CYCLE
---
>         IF (m == 0) EXIT          ! ... dry column, skip to next flux b.c. cell
598a617,622
>            IF(fresur .AND. ifacelbc(ls) == 3) THEN
>               ! ... Limit the flow rate for unconfined z-face leakage from above
>               qlim = blbc(ls)*(denlbc(ls)*philbc(ls) - gz*(denlbc(ls)*(zelbc(ls)-0.5_kdp*bblbc(ls))  &
>                    - 0.5_kdp*den(m)*bblbc(ls)))
>               qnp = MIN(qnp,qlim)
>            END IF
619,620c643,644
<      IF(m == 0) CYCLE
<      ! ... Calculate current net aquifer leakage flow rate
---
>      IF(m == 0) CYCLE          ! ... dry column, skip to next river b.c. cell
>      ! ... Calculate current net river leakage flow rate

Property changes on: uppercase.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: write2_1.f90
===================================================================
261a262
>            aprnt4(mele) = tort(ipmz)
275a277,278
>         WRITE(fulp,2014) 'Tortuosity; Vertical by Element (',TRIM(unitl),')'
>         CALL prntar(2,aprnt4,lprnt4,fulp,cnvli,24,-111)        
278c281
<         WRITE(fulp,2015) 'Molecular diffusivity-tortuosity product '//  &
---
>         WRITE(fulp,2015) 'Molecular diffusivity '//  &
Index: write3.f90
===================================================================
169c169
<            ! ... No spatial display of transient leakage data; by segment ****at present
---
>            ! ... No spatial display of transient flux data; by segment ****at present
303c303
<            ! ... No spatial display of transient leakage data; by segment
---
>            ! ... No spatial display of transient river leakage data; by segment
359d358
< !!$  IF(netbc > 0) THEN
361,372c360
< !!$     DO  m=1,nxyz
< !!$        lprnt1(m)=-1
< !!$     END DO
< !!$     DO  l=1,netbc
< !!$        m=metbc(l)
< !!$        lprnt1(m)=1
< !!$        aprnt1(m)=qetbc(l)
< !!$     END DO
< !!$     WRITE(fulp,2008) 'Maximum Evapotranspiration Volumetric Flow ','Rates (',unitl,'^3/',unittm,')'
< !!$     CALL prntar(2,aprnt1,lprnt1,fulp,cnvl3i/cnvtmi,24,000)
< !!$  END IF
< !!$  IF(naifc > 0) THEN
---
> !!$ ! ... A.I.F. b.c.
374,405d361
< !!$     DO  m=1,nxyz
< !!$        lprnt1(m)=-1
< !!$     END DO
< !!$     IF(prtdv) THEN
< !!$        DO  l=1,naifc
< !!$           m=maifc(l)
< !!$           lprnt1(m)=1
< !!$           aprnt1(m)=denoar(l)
< !!$        END DO
< !!$        WRITE(fulp,2008) 'A.I.F. Exterior Aquifer Region Density ('//unitm//'/'//unitl//'^3)'
< !!$        ifmt=12
< !!$        IF(eeunit) ifmt=13
< !!$        CALL prntar(2,aprnt1,lprnt1,fulp,cnvdi,ifmt,000)
< !!$     END IF
< !!$     IF(heat) THEN
< !!$        DO  l=1,naifc
< !!$           m=maifc(l)
< !!$           aprnt1(m)=cnvt1i*taif(l)+cnvt2i
< !!$        END DO
< !!$        WRITE (fulp,2008) 'A.I.F. Boundary Temperatures for Inflow ','(Deg.',unitt,')'
< !!$        CALL prntar(2,aprnt1,lprnt1,fulp,cnv,12,000)
< !!$     END IF
< !!$     IF(solute) THEN
< !!$        DO  l=1,naifc
< !!$           m=maifc(l)
< !!$           aprnt1(m)=caif(l)
< !!$           IF(scalmf) aprnt1(m)=(aprnt1(m)-w0)/(w1-w0)
< !!$        END DO
< !!$        WRITE (fulp,2004) 'A.I.F. Boundary '//mflbl//'Fractions for ','Inflow ( - )'
< !!$        CALL prntar(2,aprnt1,lprnt1,fulp,cnv,15,000)
< !!$     END IF
< !!$  END IF
Index: write5.f90
===================================================================
61a62
>      przf_heads = .TRUE.
104,111d104
< !!$     IF(heat) THEN
< !!$        WRITE(fuclog,aform) 'Maximum change in temperature '//dots,  &
< !!$             cnvt1i*dtmax+cnvt2i,'(Deg.'//unitt//')',  &
< !!$             'at location (',cnvli*x(itmax),',',cnvli*y(jtmax),',',cnvli*z(ktmax),')(',unitl,')'
< !!$        WRITE(*,aformt) 'Maximum change in temperature '//dots,  &
< !!$             cnvt1i*dtmax+cnvt2i,'(Deg.'//unitt//')',  &
< !!$             'at location (',cnvli*x(itmax),',',cnvli*y(jtmax),',',cnvli*z(ktmax),')(',unitl,')'
< !!$     END IF
521c514,518
< 
---
>   IF(przf_heads) THEN  
>      ! ... Zonal heads to file, fuzf_heads
>      CALL zone_flow_write_heads
>      ntprzf_heads = ntprzf_heads+1
>   END IF
937,940d933
<         IF(heat.AND.prthd2) THEN
<            WRITE(fubcf,2042) 'Associated Heat   ('//unithf//')'
<            CALL prntar(2,aprnt2,lprnt2,fubcf,cnvhfi,24,000)
<         END IF
964,982d956
< !!$        IF(heat) THEN
< !!$           DO  m=1,nxyz
< !!$              lprnt1(m)=-1
< !!$           END DO
< !!$           prthd=.FALSE.
< !!$           DO  l=1,nsbc
< !!$              m=msbc(l)
< !!$              WRITE(cibc,3007) ibc(m)
< !!$              IF(cibc(4:4) == '1') THEN
< !!$                 !                     APRNT1(M)=QHSBC(L)
< !!$                 lprnt1(m)=1
< !!$                 prthd=.TRUE.
< !!$              END IF
< !!$           END DO
< !!$           IF(prthd) THEN
< !!$              WRITE(fubcf,2042) 'Heat   ('//unithf//')'
< !!$              CALL prntar(2,aprnt1,lprnt1,fubcf,cnvhfi,24,000)
< !!$           END IF
< !!$        END IF
1022c996
<            IF (m > 0) THEN
---
>            IF (m > 0) THEN          ! ... skip over dry columns of cells
1028,1034d1001
< !!$        IF(erflg) THEN
< !!$           WRITE(fuclog,9001) 'EHOFTP interpolation error in WRITE5 ','Specified flux b.c '
< !!$9001       FORMAT(tr10,2A,i4)
< !!$           ierr(134)=.TRUE.
< !!$           errexe=.TRUE.
< !!$           RETURN
< !!$        END IF
1037,1040d1003
< !!$        IF(heat .AND. prthd) THEN
< !!$           WRITE(fubcf,2042) 'Associated Advective Heat   ('// unithf//')'
< !!$           CALL prntar(2,aprnt2,lprnt1,fubcf,cnvmfi,24,000)
< !!$        END IF
1069,1088d1031
< !!$        IF(heat) THEN
< !!$           DO  m=1,nxyz
< !!$              lprnt1(m)=-1
< !!$           END DO
< !!$           prthd=.FALSE.
< !!$           DO  l=1,nfbc
< !!$              m=mfbc(l)
< !!$              WRITE(cibc,3007) ibc(m)
< !!$              ic=INDEX(cibc(4:6),'2')
< !!$              IF(ic > 0) THEN
< !!$                 lprnt1(m)=1
< !!$                 prthd=.TRUE.
< !!$                 !                     APRNT1(M)=QHFBC(L)
< !!$              END IF
< !!$           END DO
< !!$           IF(prthd) THEN
< !!$              WRITE(fubcf,2042) 'Heat   ('//unithf//')'
< !!$              CALL prntar(2,aprnt1,lprnt1,fubcf,cnvhfi,24,000)
< !!$           END IF
< !!$        END IF
1134,1135d1076
<            !$$                 APRNT2(M)=QHLBC(L)
<            !$$                 APRNT3(M)=QSLBC(L)
1138,1141d1078
< !!$        IF(heat) THEN
< !!$           WRITE(fubcf,2042) 'Leakage B.C.: Associated Advective Heat   ('// unithf//')'
< !!$           CALL prntar(2,aprnt2,lprnt1,fubcf,cnvhfi,24,000)
< !!$        END IF
1162a1100
>            IF (m > 0) THEN
1164a1103
>            ENDIF
1167,1170d1105
< !!$        IF(heat) THEN
< !!$           WRITE(fubcf,2042) 'Associated Advective Heat   ('// unithf//')'
< !!$           CALL prntar(2,aprnt2,lprnt1,fubcf,cnvhfi,24,000)
< !!$        END IF
1174a1110
>                  IF (m > 0) THEN
1175a1112
>                  END IF
1195,1198d1131
< !!$        IF(heat) THEN
< !!$           WRITE(fubcf,2042) 'Associated Advective Heat   ('// unithf//')'
< !!$           CALL prntar(2,aprnt2,lprnt1,fubcf,cnvhfi,24,000)
< !!$        END IF
1267,1296d1199
< !!$     END IF
< !!$     IF(nhcbc > 0) THEN
< !!$        !... **not available for PHAST
< !!$        WRITE(fubcf,2043) 'Heat Conduction B.C. Heat Flow Rates ',  &
< !!$             '(positive is into the region)'
< !!$        DO  m=1,nxyz
< !!$           lprnt1(m)=-1
< !!$        END DO
< !!$        DO  l=1,nhcbc
< !!$           m=mhcbc(l)
< !!$           aprnt1(m)=qhcbc(l)
< !!$           lprnt1(m)=1
< !!$        END DO
< !!$        WRITE(fubcf,2042) 'Heat   ('//unithf//')'
< !!$        CALL prntar(2,aprnt1,lprnt1,fubcf,cnvhfi,24,000)
< !!$        WRITE(fubcf,2043) 'Heat Conduction B.C. Temperature Profiles ', &
< !!$             'Rows are normal to the boundary '
< !!$        WRITE(fubcf,2042) 'Temperature  (Deg.'//unitt//')'
< !!$        WRITE(fubcf,2044) 'B.C. Node No.'
< !!$2044    FORMAT(tr1,a)
< !!$        DO  l=1,nhcbc
< !!$           WRITE(fubcf,2045) l
< !!$2045       FORMAT(i3)
< !!$           lll=(l-1)*nhcn
< !!$           DO  ll=1,nhcn
< !!$              aprnt1(ll)=cnvt1i*thcbc(lll+ll)+cnvt2i
< !!$              lprnt1(ll)=1
< !!$           END DO
< !!$           CALL prntar(1,aprnt1,lprnt1,fubcf,cnv,12,nhcn)
< !!$        END DO
Index: write5_ss_flow.f90
===================================================================
53a54
>   przf_heads = .FALSE.
86a88,90
>      IF(ABS(pri_zf_heads) > 0._kdp) THEN
>         IF(converge_ss) przf_heads=.TRUE.
>      END IF            
310a315,319
>   IF(przf_heads) THEN  
>      ! ... Zonal heads to file, fuzf_heads
>      CALL zone_flow_write_heads
>      ntprzf_heads = ntprzf_heads+1
>   END IF  
502c511
<            IF (m > 0) THEN
---
>            IF (m > 0) THEN            ! ... skip dry columns of cells
519,520d527
<            !$$                 APRNT2(M)=QHLBC(L)
<            !$$                 APRNT3(M)=QSLBC(L)
529a537
>            IF (m > 0) THEN
531a540
>            ENDIF
548,563d556
< !!$        WRITE(fubcf,2043) 'Evapotranspiration Flow Rates ','(positive is into the region)'
< !!$        WRITE(fubcf,2042) 'Fluid   (',unitm,'/',TRIM(unittm),')'
< !!$        DO  m=1,nxyz
< !!$           lprnt1(m)=-1
< !!$        END DO
< !!$        DO  l=1,netbc
< !!$           m=metbc(l)
< !!$           ! ... Locate the flux at the cell containing the free-surface
< !!$           l1=MOD(m,nxy)
< !!$           IF(l1 == 0) l1=nxy
< !!$           m=mfsbc(l1)
< !!$           aprnt1(m)=qfetbc(l)
< !!$           lprnt1(m)=1
< !!$        END DO
< !!$        CALL prntar(2,aprnt1,lprnt1,fubcf,cnvmfi,24,000)
< !!$     END IF
566,580d558
< !!$        WRITE(fubcf,2043) 'Aquifer Influence Function Flow Rates','(positive is into the region)'
< !!$        WRITE(fubcf,2042) 'Fluid   (',unitm,'/',TRIM(unittm),')'
< !!$        DO  m=1,nxyz
< !!$           aprnt1(m)=0.d0
< !!$           aprnt2(m)=0.d0
< !!$           aprnt3(m)=0.d0
< !!$           lprnt1(m)=-1
< !!$        END DO
< !!$        DO  l=1,naifc
< !!$           m=maifc(l)
< !!$           aprnt1(m)=aprnt1(m)+qfaif(l)
< !!$           lprnt1(m)=1
< !!$        END DO
< !!$        CALL prntar(2,aprnt1,lprnt1,fubcf,cnvmfi,24,000)
< !!$     END IF
Index: zone_flow.f90
===================================================================
25c25
<   CHARACTER(LEN=80) :: ident_string='$Id: zone_flow.f90,v 1.1 2009/05/07 19:46:55 klkipp Exp $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: zone_flow.f90,v 1.2 2010/03/05 18:19:02 klkipp Exp $'
624a625,742
> SUBROUTINE zone_flow_write_heads
>   ! ... Writes heads for zones 
>   USE machine_constants, ONLY: kdp
>   USE f_units
>   USE mcb2
>   USE mcch
>   USE mcg
>   USE mcn, ONLY: x, y, z
>   USE mcp
>   USE mcv
>   USE mg2, ONLY: hdprnt
> !!$  USE phys_const
>   IMPLICIT NONE
>   !LOGICAL ex
>   INTEGER ios
>   INTEGER i, ii, jj, kk, m, izn
>   REAL(KIND=kdp) :: current_time = 0
>   INTEGER :: counter = 1
>   SAVE current_time, counter
>  
>   current_time = cnvtmi*time
>   do izn = 1, num_flo_zones
>     if (zone_write_heads(izn)) then
>         if (counter == 1) then
>             ! delete file on first write
>             OPEN(fuzf_heads,FILE=zone_filename_heads(izn),IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
>             write(fuzf_heads,"(a20,a20,a20,a13,a6,a1,a20)") "X","Y","Z","T(",TRIM(unittm),")","Head"
>         else
>             OPEN(fuzf_heads,FILE=zone_filename_heads(izn),IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
>         endif 
>         do i = 1, zone_col(izn)%num_xycol
>             ii = zone_col(izn)%i_no(i)
>             jj = zone_col(izn)%j_no(i)
>             do kk = zone_col(izn)%kmin_no(i), zone_col(izn)%kmax_no(i)
>                 m = ii + (jj-1)*nx + (kk-1)*nxy
>                 if (frac(m) > 0.0)then
>                     write(fuzf_heads,"(5(G20.10,A1))") cnvli*x(ii),ACHAR(9),cnvli*y(jj),ACHAR(9),cnvli*z(kk),  &
>                           ACHAR(9),current_time,ACHAR(9),cnvli*hdprnt(m),ACHAR(9)      
>                 endif
>             end do
>          end do
>          CLOSE(fuzf_heads, status='KEEP')
>      endif    
>   end do
>            
>   counter = counter + 1
> 
> END SUBROUTINE zone_flow_write_heads
> !SUBROUTINE subgrid
> !  ! ... Calculates flow rates for each internal zone
> !  USE machine_constants, ONLY: kdp
> !  USE mcb
> !  USE mcb2
> !  USE mcc, ONLY: cylind
> !  USE mcg
> !  USE mcn, ONLY: x, y, z
> !  USE mcp
> !  USE mcv
> !  USE mcw
> !  USE mg2, ONLY: hdprnt
> !!!$  USE phys_const
> !  IMPLICIT NONE
> !  LOGICAL ex
> !  INTEGER iunit, junit, ios
> !  INTEGER i, j, k, ii, jj, kk, m
> !  REAL(KIND=kdp), STATIC :: current_time = 0
> !  INTEGER, STATIC :: counter = 1
> !
> !  CHARACTER(LEN=100) :: char_100, fname, fname_xyzt
> !  if (num_flo_zones > 0) then
> !
> !    WRITE(char_100,*) counter
> !    char_100 = ADJUSTL(char_100)
> !    char_100 = TRIM(char_100)
> !    fname = "0/subgrid/subgrid.head."//char_100
> !    fname_xyzt = "subgrid/xyzt.heads.dat"
> !
> !    iunit = 101
> !
> !
> !    if (counter == 1) then
> !        OPEN(iunit,FILE='subgrid/subgrid.input',IOSTAT=ios,STATUS='REPLACE')
> !        CLOSE(iunit)
> !        OPEN(iunit,FILE=fname_xyzt,IOSTAT=ios,STATUS='REPLACE')
> !        CLOSE(iunit)
> !    endif
> !    OPEN(iunit,FILE='subgrild/subgrid.input',IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
> !    WRITE(iunit,*) current_time," XYZ grid ", TRIM(fname) 
> !    CLOSE(iunit, status='KEEP')
> !    
> !    fname = "subgrid/subgrid.head."//char_100
> !    junit = 102
> !    OPEN(junit,FILE=fname,IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
> !    OPEN(iunit,FILE=fname_xyzt,IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
> !!  TYPE :: zone_volume
> !!     INTEGER :: num_xycol
> !!     INTEGER, DIMENSION(:), POINTER :: i_no, j_no, kmin_no, kmax_no
> !!  END TYPE zone_volume
> !    do i = 1, zone_col(1)%num_xycol
> !        ii = zone_col(1)%i_no(i)
> !        jj = zone_col(1)%j_no(i)
> !        do kk = zone_col(1)%kmin_no(i), zone_col(1)%kmax_no(i)
> !            m = ii + (jj-1)*nx + (kk-1)*nxy
> !            if (frac(m) > 0.0)then
> !                write(junit,"(4(G20.10,A1))") cnvli*x(ii),ACHAR(9),cnvli*y(jj),ACHAR(9),cnvli*z(kk),  &
> !                      ACHAR(9),cnvli*hdprnt(m),ACHAR(9)
> !                write(iunit,"(5(G20.10,A1))") cnvli*x(ii),ACHAR(9),cnvli*y(jj),ACHAR(9),cnvli*z(kk),  &
> !                      ACHAR(9),current_time,ACHAR(9),cnvli*hdprnt(m),ACHAR(9)      
> !            endif
> !        end do
> !     end do
> !     CLOSE(junit, status='KEEP')
> !     CLOSE(iunit, status='KEEP')
> !     current_time = cnvtmi*time
> !     counter = counter + 1
> !  end if
> !
> !  END SUBROUTINE subgrid

Property changes on: zone_flow.f90
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: zone_flow_ss.f90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: closef.F90
===================================================================
25c25
<   CHARACTER(LEN=6), DIMENSION(40) :: st
---
>   CHARACTER(LEN=6), DIMENSION(50) :: st
27a28
>   INTEGER izn
33c34,35
<   CLOSE(fuins,STATUS='DELETE')  
---
>   !$$CLOSE(fuins,STATUS='DELETE') 
>   CALL MYCLOSE(fuins, 'DELETE')
163a166,169
>   ! fuzf_heads opened and closed in zone_flow_write_heads 
>   ! for multiple files 
>   !st(fuzf_heads) = 'delete'    
>   !IF(ntprzf_heads > 0) st(fuzf_heads) = 'keep  '  
169,189c175,216
<   IF(print_rde) CLOSE(furde,status='keep')  
<   CLOSE(fuorst, status = st(fuorst))  
<   CLOSE(fulp, status = st(fulp))  
<   CLOSE(fup, status = st(fup))  
<   CLOSE(fuwt, status = st(fuwt))  
<   CLOSE(fuc, status = st(fuc))  
<   CLOSE(fuvel, status = st(fuvel))  
<   CLOSE(fuwel, status = st(fuwel))  
<   CLOSE(fubal, status = st(fubal))  
<   CLOSE(fukd, status = st(fukd))  
<   CLOSE(fubcf, status = st(fubcf))  
<   CLOSE(fuzf, status = st(fuzf))
<   CLOSE(fuzf_tsv, status = st(fuzf_tsv))
<   CLOSE(fuplt, status = st(fuplt))  
<   CLOSE(fupmap, status = st(fupmap))  
<   CLOSE(fupmp2, status = st(fupmp2))  
<   CLOSE(fupmp3, status = st(fupmp3))  
<   CLOSE(fuvmap, status = st(fuvmap))  
< !!$  close(fupzon, status = st(fupzon))  
< !!$  close(fubnfr, status = st(fubcf))  
<   CLOSE(fuich, status = st(fuich))
---
> !  IF(print_rde) CLOSE(furde,status='keep')  
> !  CLOSE(fuorst, status = st(fuorst))  
> !  CLOSE(fulp, status = st(fulp))  
> !  CLOSE(fup, status = st(fup))  
> !  CLOSE(fuwt, status = st(fuwt))  
> !  CLOSE(fuc, status = st(fuc))  
> !  CLOSE(fuvel, status = st(fuvel))  
> !  CLOSE(fuwel, status = st(fuwel))  
> !  CLOSE(fubal, status = st(fubal))  
> !  CLOSE(fukd, status = st(fukd))  
> !  CLOSE(fubcf, status = st(fubcf))  
> !  CLOSE(fuzf, status = st(fuzf))
> !  CLOSE(fuzf_tsv, status = st(fuzf_tsv))
> !  CLOSE(fuplt, status = st(fuplt))  
> !  CLOSE(fupmap, status = st(fupmap))  
> !  CLOSE(fupmp2, status = st(fupmp2))  
> !  CLOSE(fupmp3, status = st(fupmp3))  
> !  CLOSE(fuvmap, status = st(fuvmap))  
> !!!$  close(fupzon, status = st(fupzon))  
> !!!$  close(fubnfr, status = st(fubcf))  
> !  CLOSE(fuich, status = st(fuich))
> 
>   IF(print_rde) CALL MYCLOSE(furde, 'keep')  
>   CALL MYCLOSE(fuorst, st(fuorst))  
>   CALL MYCLOSE(fulp, st(fulp))  
>   CALL MYCLOSE(fup, st(fup))  
>   CALL MYCLOSE(fuwt, st(fuwt))  
>   CALL MYCLOSE(fuc, st(fuc))  
>   CALL MYCLOSE(fuvel, st(fuvel))  
>   CALL MYCLOSE(fuwel, st(fuwel))  
>   CALL MYCLOSE(fubal, st(fubal))  
>   CALL MYCLOSE(fukd, st(fukd))  
>   CALL MYCLOSE(fubcf, st(fubcf))  
>   CALL MYCLOSE(fuzf, st(fuzf))
>   CALL MYCLOSE(fuzf_tsv, st(fuzf_tsv))
>   CALL MYCLOSE(fuplt, st(fuplt))  
>   CALL MYCLOSE(fupmap, st(fupmap))  
>   CALL MYCLOSE(fupmp2, st(fupmp2))  
>   CALL MYCLOSE(fupmp3, st(fupmp3))  
>   CALL MYCLOSE(fuvmap, st(fuvmap))  
>   CALL MYCLOSE(fuich, st(fuich))
>   
199c226,227
<           ibc, ibc_string,  &
---
>           ibc, pv0, volume, &
>           cellijk, ibc_string, &
201c229
<           xd_mask, vmask,  &
---
>           xd_mask, &
204c232
<         PRINT *, "Array allocation failed: closef: number 0"
---
>         PRINT *, "Array deallocation failed: closef: number 0"
207c235
<   ! ... Allocate mesh arrays for chem slaves
---
>   ! ... Deallocate mesh arrays for chem slaves
218c246,248
<           sxx, syy, szz, vxx, vyy, vzz, dcmax, dsir, &
---
>           sxx, syy, szz, vxx, vyy, vzz, &
>           vx_node, vy_node, vz_node, vmask, zfs, &
>           dcmax, dsir, dsir_chem, &
221c251,252
<           stsrbc, stssbc, stswel, ssresf, ssres, stotsi, stotsp, &
---
>           stsrbc, stsdbc, stssbc, &
>           stswel, ssresf, ssres, stotsi, stotsp, &
226c257,258
<           sir, sir0, sirn, totsi, totsp, tcsaif, tcsetb, &
---
>           sir, sir0, sirn, sir_prechem, &
>           totsi, totsp, tdsir_chem, tcsaif, tcsetb, &
228c260
<           tcslbc, tcsrbc, tcssbc, &
---
>           tcslbc, tcsrbc, tcsdbc, tcssbc, &
230c262
<           tqwsi, tqwsp, u10, zfs, &
---
>           tqwsi, tqwsp, u10, &
233c265
<         PRINT *, "Array allocation failed: closef: number 2"  
---
>         PRINT *, "Array deallocation failed: closef: number 2"  
235a268,398
> 
>      
>         do izn = 1, num_flo_zones
>         
>           ! deallocate list of cell top and bottom numbers if needed
>           IF((fresur .AND. (nfbc > 0 .OR. nrbc > 0)) .or. zone_write_heads(izn)) THEN
>             DEALLOCATE (zone_col(izn)%i_no,  &
>                 zone_col(izn)%j_no,  &
>                 zone_col(izn)%kmin_no,  &
>                 zone_col(izn)%kmax_no,  &
>                 stat = da_err)
>             IF (da_err /= 0) THEN
>               PRINT *, "Array deallocation failed: closef: number 2.0"
>               STOP
>             ENDIF       
>           ENDIF 
>           
>           ! flow zone face parameters
>           IF(zone_ib(izn)%num_int_faces > 0) THEN
>             DEALLOCATE (zone_ib(izn)%mcell_no,  &
>               zone_ib(izn)%face_indx,  &
>               stat = da_err)
>             IF (da_err /= 0) THEN
>               PRINT *, "Array deallocation failed: closef: number 2.1"
>               STOP
>             ENDIF 
>           ENDIF     
>           
>           ! Flow Zone Specified Head B.C. Cells
>           IF(nsbc_cells > 0 .and. lnk_bc2zon(izn,1)%num_bc > 0) THEN  
>             DEALLOCATE (lnk_bc2zon(izn,1)%lcell_no,  &
>                  stat = da_err)
>             IF (da_err /= 0) THEN
>                PRINT *, "Array deallocation failed: closef: number 2.2"
>                STOP
>             ENDIF          
>           ENDIF  ! nsbc cells  
>           
>           IF(nfbc_cells > 0) THEN
>             ! Flow Zone Flux B.C. Cells
>             IF(lnk_bc2zon(izn,2)%num_bc > 0) THEN
>               DEALLOCATE (lnk_bc2zon(izn,2)%lcell_no,  &
>                     stat = da_err)
>               IF (da_err /= 0) THEN
>                   PRINT *, "Array deallocation failed: closef: number 2.3"
>                   STOP
>               ENDIF
>             END IF
>            
>             ! Flow Zone Conditional Flux B.C. Cells
>             IF(fresur) THEN
>               IF(lnk_cfbc2zon(izn)%num_bc > 0) THEN
>                 ! ... Deallocate scratch space for flux cells
>                 DEALLOCATE (lnk_cfbc2zon(izn)%lcell_no,  &
>                       lnk_cfbc2zon(izn)%mxy_no,  &
>                       lnk_cfbc2zon(izn)%icz_no,  &
>                       stat = da_err)
>                 IF (da_err /= 0) THEN
>                   PRINT *, "Array deallocation failed: closef: number 2.4"
>                   STOP
>                 ENDIF
>               END IF
>             END IF          
>           END IF  ! nfbc cells
>           
>           IF(nlbc_cells > 0) THEN
>             IF(lnk_bc2zon(izn,3)%num_bc > 0) THEN
>               ! ... Deallocate scratch space for leakage cells
>               DEALLOCATE (lnk_bc2zon(izn,3)%lcell_no,  &
>                    stat = da_err)
>               IF (da_err /= 0) THEN
>                  PRINT *, "Array deallocation failed: closef: number 2.5"
>                  STOP
>               ENDIF
>             END IF 
>           END IF ! nlbc cells
>           
>           ! Flow Zone River Leakage B.C. Cells
>           IF(fresur .AND. nrbc_cells > 0) THEN
>             IF(lnk_crbc2zon(izn)%num_bc > 0) THEN
>               DEALLOCATE (lnk_crbc2zon(izn)%lcell_no,  &
>                    lnk_crbc2zon(izn)%mxy_no,  &
>                    lnk_crbc2zon(izn)%icz_no,  &
>                    stat = da_err)
>               IF (da_err /= 0) THEN
>                  PRINT *, "Array deallocation failed: closef: number 2.6"
>                  STOP
>               ENDIF
>             END IF  
>           END IF  ! nrbc cells    
>           
>           ! Flow Zone Drain B.C. Cells   
>           IF(ndbc_cells > 0) THEN
>             IF(lnk_bc2zon(izn,4)%num_bc > 0) THEN
>               DEALLOCATE (lnk_bc2zon(izn,4)%lcell_no,  &
>                    stat = da_err)
>               IF (da_err /= 0) THEN
>                  PRINT *, "Array deallocation failed: closef: number 2.7"
>                  STOP
>               ENDIF
>             END IF
>           END IF  ! ndbc cells  
>  
>          IF(nwel > 0) THEN
>            IF(seg_well(izn)%num_wellseg > 0 ) THEN
>               DEALLOCATE (seg_well(izn)%iwel_no,  &
>                    seg_well(izn)%ks_no,  &
>                    stat = da_err)
>               IF (da_err /= 0) THEN
>                  PRINT *, "Array deallocation failed: closef: number 2.8"
>                  STOP
>               ENDIF
>             END IF
>           END IF  ! nwel       
>         enddo  ! num_flo_zones
>               
>         DEALLOCATE (zone_title, &
>           zone_ib, lnk_bc2zon, &
>           seg_well, &
>           zone_filename_heads, &
>           zone_write_heads, &               
>           stat = da_err)
>         IF (da_err /= 0) THEN
>           PRINT *, "Array deallocation failed: closef: number 2.X"
>           STOP
>         ENDIF       
>      
>      
>      
>      
>      
237,238c400,403
<         DEALLOCATE (qfzoni, qfzonp, qszoni, qszonp,  &
<              zone_ib, lnk_bc2zon, zone_title,  &
---
>         DEALLOCATE (qfzoni, qfzonp, &
>              qszoni, qszonp, &
>              qfzoni_int, qfzonp_int,  &
>              qszoni_int, qszonp_int,  &             
250c415
<              qszoni_wel, qszonp_wel, seg_well,  &
---
>              qszoni_wel, qszonp_wel, &
256c421
<         IF(fresur) THEN
---
>         IF(ALLOCATED(zone_col)) THEN
276c441
<   DEALLOCATE (abpm, alphl, alphth, alphtv, poros,  &
---
>   DEALLOCATE (abpm, alphl, alphth, alphtv, tort, poros, &
282c447,451
<      PRINT *, "Array allocation failed: closef: number 4"  
---
>      PRINT *, "Array deallocation failed: closef: number 4"  
>   ENDIF
>   DEALLOCATE (kx, ky, kz, stat = da_err)
>   IF (da_err /= 0) THEN  
>      PRINT *, "Array allocation failed: closef: number 4.1"  
293c462
<         PRINT *, "Array allocation failed: closef: number 5"  
---
>         PRINT *, "Array deallocation failed: closef: number 5"  
302c471,474
<           qwm, qwv, qhw, stfwp, sthwp, &
---
>           tfw, &
>           qwm, qwv, qhw, &
>           rhsw, vaw, &
>           stfwp, sthwp, &
311c483,484
<   IF (nsbc > 0 .AND. nwel > 0) THEN
---
>   !IF (nsbc > 0 .AND. nwel > 0) THEN
>   IF (nwel > 0) THEN
326c499
<           mrbc_bot, mrseg_bot,  &
---
>           mrbc_bot,  mrbc_top, mrseg_bot,  &
361a535,538
>   DEALLOCATE (b_cell, stat = da_err)
>   IF (da_err /= 0) THEN  
>      PRINT *, "Array deallocation failed: closef: number 9.1" 
>   ENDIF 
444c621
<   DEALLOCATE (mfsbc, hdprnt, wt_elev,  &
---
>   DEALLOCATE (mfsbc, print_dry_col, hdprnt, wt_elev,  &
449a627,647
> 
> SUBROUTINE MYCLOSE(funit, st)
>     IMPLICIT NONE
>     CHARACTER(*), intent(in) :: st
>     INTEGER, intent(in) :: funit
>     INTEGER :: ios
>     INTEGER :: count
>     
>     count =0
>     ios = 1
>     DO WHILE (ios > 0) 
>         CLOSE(funit, STATUS=st,IOSTAT=ios)
> !        if (ios > 0) print *, "Retry ", count, "closing unit ", funit, " iostat ", ios, st
>         count = count + 1
>         if (count > 20) exit
>     end do
>     if (ios > 0) then
>         print *, "Could not close unit ", funit
>     endif
>     return
> END SUBROUTINE MYCLOSE
Index: mpimod.F90
===================================================================
20,95c20,95
< !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<   ! init_mpi
<   !
<   ! Preconditions:
<   !   none
<   !
<   ! Postconditions:
<   !   g_mpi_tasks and g_mpi_myself are valid
< !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<   SUBROUTINE init_mpi(mpi_tasks, mpi_myself)
<     IMPLICIT NONE
< !MS$ NOFREEFORM
<       INCLUDE 'mpif.h'
< !MS$ FREEFORM
< #if defined(_WIN32)
<     !MS$ ATTRIBUTES Default :: mpi_dup_fn    
<     !MS$ ATTRIBUTES Default :: mpi_null_delete_fn    
<     !MS$ ATTRIBUTES Default :: mpi_null_copy_fn    
<     !MS$ ATTRIBUTES Default :: mpi_comm_dup_fn    
<     !MS$ ATTRIBUTES Default :: mpi_comm_null_delete_fn
<     !MS$ ATTRIBUTES Default :: mpi_comm_null_copy_fn
<     !MS$ ATTRIBUTES Default :: mpi_win_dup_fn
<     !MS$ ATTRIBUTES Default :: mpi_win_null_delete_fn
<     !MS$ ATTRIBUTES Default :: mpi_win_null_copy_fn
<     !MS$ ATTRIBUTES Default :: mpi_type_dup_fn
<     !MS$ ATTRIBUTES Default :: mpi_type_null_delete_fn
<     !MS$ ATTRIBUTES Default :: mpi_type_null_copy_fn
<     !MS$ ATTRIBUTES Default :: mpi_conversion_fn_null
< #endif
<     INTERFACE
<        SUBROUTINE MPI_INIT_(ierror)
< #if defined(_WIN32)
<          !MS$ ATTRIBUTES Default :: MPI_INIT
< #endif
<          INTEGER ierror
<        END SUBROUTINE MPI_INIT_
<        SUBROUTINE MPI_COMM_SIZE_(comm, size, ierror)
< #if defined(_WIN32)
<          !MS$ ATTRIBUTES Default :: MPI_COMM_SIZE
< #endif
<          INTEGER :: comm
<          INTEGER :: size
<          INTEGER :: ierror
<        END SUBROUTINE MPI_COMM_SIZE_
<        SUBROUTINE MPI_COMM_RANK_(comm, rank, ierror)
< #if defined(_WIN32)
<          !MS$ ATTRIBUTES Default :: MPI_COMM_RANK
< #endif
<          INTEGER :: comm
<          INTEGER :: rank
<          INTEGER :: ierror
<        END SUBROUTINE MPI_COMM_RANK_
<     END INTERFACE
< 
<     INTEGER, INTENT(OUT) :: mpi_tasks
<     INTEGER, INTENT(OUT) :: mpi_myself
<     INTEGER :: my_mpi_error
< 
<     CALL MPI_INIT_(my_mpi_error)
<     IF (my_mpi_error /= 0) THEN
<        WRITE(*,*) "MPI_INIT failed."
<        STOP "Stopping."
<     ENDIF
<     CALL MPI_COMM_SIZE_(MPI_COMM_WORLD, mpi_tasks, my_mpi_error)
<     IF (my_mpi_error /= 0) THEN
<        WRITE(*,*) "MPI_COMM_SIZE failed."
<        STOP "Stopping."
<     ENDIF
<     CALL MPI_COMM_RANK_(MPI_COMM_WORLD, mpi_myself, my_mpi_error)
<     IF (my_mpi_error /= 0) THEN
<        WRITE(*,*) "MPI_COMM_RANK failed."
<        STOP "Stopping."
<     ENDIF
<     g_mpi_tasks = mpi_tasks
<     g_mpi_myself = mpi_myself
<   END SUBROUTINE init_mpi
---
> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> !!!!  ! init_mpi
> !!!!  !
> !!!!  ! Preconditions:
> !!!!  !   none
> !!!!  !
> !!!!  ! Postconditions:
> !!!!  !   g_mpi_tasks and g_mpi_myself are valid
> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> !!!!  SUBROUTINE init_mpi(mpi_tasks, mpi_myself)
> !!!!    IMPLICIT NONE
> !!!!!MS$ NOFREEFORM
> !!!!      INCLUDE 'mpif.h'
> !!!!!MS$ FREEFORM
> !!!!#if defined(_WIN32)
> !!!!    !MS$ ATTRIBUTES Default :: mpi_dup_fn    
> !!!!    !MS$ ATTRIBUTES Default :: mpi_null_delete_fn    
> !!!!    !MS$ ATTRIBUTES Default :: mpi_null_copy_fn    
> !!!!    !MS$ ATTRIBUTES Default :: mpi_comm_dup_fn    
> !!!!    !MS$ ATTRIBUTES Default :: mpi_comm_null_delete_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_comm_null_copy_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_win_dup_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_win_null_delete_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_win_null_copy_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_type_dup_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_type_null_delete_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_type_null_copy_fn
> !!!!    !MS$ ATTRIBUTES Default :: mpi_conversion_fn_null
> !!!!#endif
> !!!!    INTERFACE
> !!!!       SUBROUTINE MPI_INIT_(ierror)
> !!!!#if defined(_WIN32)
> !!!!         !MS$ ATTRIBUTES Default :: MPI_INIT
> !!!!#endif
> !!!!         INTEGER ierror
> !!!!       END SUBROUTINE MPI_INIT_
> !!!!       SUBROUTINE MPI_COMM_SIZE_(comm, size, ierror)
> !!!!#if defined(_WIN32)
> !!!!         !MS$ ATTRIBUTES Default :: MPI_COMM_SIZE
> !!!!#endif
> !!!!         INTEGER :: comm
> !!!!         INTEGER :: size
> !!!!         INTEGER :: ierror
> !!!!       END SUBROUTINE MPI_COMM_SIZE_
> !!!!       SUBROUTINE MPI_COMM_RANK_(comm, rank, ierror)
> !!!!#if defined(_WIN32)
> !!!!         !MS$ ATTRIBUTES Default :: MPI_COMM_RANK
> !!!!#endif
> !!!!         INTEGER :: comm
> !!!!         INTEGER :: rank
> !!!!         INTEGER :: ierror
> !!!!       END SUBROUTINE MPI_COMM_RANK_
> !!!!    END INTERFACE
> !!!!
> !!!!    INTEGER, INTENT(OUT) :: mpi_tasks
> !!!!    INTEGER, INTENT(OUT) :: mpi_myself
> !!!!    INTEGER :: my_mpi_error
> !!!!
> !!!!    CALL MPI_INIT_(my_mpi_error)
> !!!!    IF (my_mpi_error /= 0) THEN
> !!!!       WRITE(*,*) "MPI_INIT failed."
> !!!!       STOP "Stopping."
> !!!!    ENDIF
> !!!!    CALL MPI_COMM_SIZE_(MPI_COMM_WORLD, mpi_tasks, my_mpi_error)
> !!!!    IF (my_mpi_error /= 0) THEN
> !!!!       WRITE(*,*) "MPI_COMM_SIZE failed."
> !!!!       STOP "Stopping."
> !!!!    ENDIF
> !!!!    CALL MPI_COMM_RANK_(MPI_COMM_WORLD, mpi_myself, my_mpi_error)
> !!!!    IF (my_mpi_error /= 0) THEN
> !!!!       WRITE(*,*) "MPI_COMM_RANK failed."
> !!!!       STOP "Stopping."
> !!!!    ENDIF
> !!!!    g_mpi_tasks = mpi_tasks
> !!!!    g_mpi_myself = mpi_myself
> !!!!  END SUBROUTINE init_mpi
Index: openf.F90
===================================================================
49c49,50
<   OPEN(fulp,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fulp,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fulp, fname, ios)
60c61,62
<      OPEN(furde,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>      !OPEN(furde,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>      CALL MYOPEN(furde, fname, ios)
70c72,73
<   OPEN(fup,FILE=fname,IOSTAT=ios, ACTION='WRITE')
---
>   !OPEN(fup,FILE=fname,IOSTAT=ios, ACTION='WRITE')
>   CALL MYOPEN(fup, fname, ios)
79c82,83
<   OPEN(fuwt,FILE=fname,IOSTAT=ios, ACTION='WRITE')
---
>   !OPEN(fuwt,FILE=fname,IOSTAT=ios, ACTION='WRITE')
>   CALL MYOPEN(fuwt, fname, ios)
88c92,93
<   OPEN(fuc,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuc,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuc, fname, ios)
97c102,103
<   OPEN(fuvel,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuvel,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuvel, fname, ios)
106c112,113
<   OPEN(fuwel,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuwel,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuwel, fname, ios)
115c122,123
<   OPEN(fubal,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fubal,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fubal, fname, ios)
124c132,133
<   OPEN(fukd,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fukd,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fukd, fname, ios)
133c142,143
<   OPEN(fubcf,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fubcf,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fubcf, fname, ios)
142c152,153
<   OPEN(fuzf,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuzf,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuzf, fname, ios)
151c162,163
<   OPEN(fuzf_tsv,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuzf_tsv,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuzf_tsv, fname, ios)
163c175,176
<   OPEN(fupmap,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fupmap,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fupmap, fname, ios)
172c185,186
<   OPEN(fupmp2,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fupmp2,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fupmp2, fname, ios)
181c195,196
<   OPEN(fupmp3,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fupmp3,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fupmp3, fname, ios)
190c205,206
<   OPEN(fuvmap,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuvmap,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuvmap, fname, ios)
199c215,216
<   OPEN(fuplt,FILE=fname,IOSTAT=ios,ACTION='WRITE')
---
>   !OPEN(fuplt,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>   CALL MYOPEN(fuplt, fname, ios)
214a232,246
> SUBROUTINE MYOPEN(funit, fname, ios)
>     CHARACTER(LEN=255), intent(in) :: fname
>     INTEGER, intent(in) :: funit
>     INTEGER, intent(out) :: ios
>     INTEGER :: count
>     
>     count =0
>     ios = 1
>     DO WHILE (ios > 0) 
>         OPEN(funit,FILE=fname,IOSTAT=ios,ACTION='WRITE')
>         count = count + 1
>         if (count > 20) exit
>     end do
>     return
> END SUBROUTINE MYOPEN
Index: phast.F90
===================================================================
1c1
< PROGRAM phast
---
> SUBROUTINE phast_sub(mpi_tasks, mpi_myself)
39c39
<   version_name = ' 1.2'
---
>   version_name = ' @VERSION@'
41,42d40
<   mpi_tasks = 1
<   mpi_myself = 0
44c42,44
<   CALL init_mpi(mpi_tasks, mpi_myself)
---
>     g_mpi_tasks = mpi_tasks
>     g_mpi_myself = mpi_myself
> !!  CALL init_mpi(mpi_tasks, mpi_myself)
53c53
< END PROGRAM phast
---
> END SUBROUTINE phast_sub
Index: phast_root.F90
===================================================================
7c7
<   USE mcn, ONLY: x_node, y_node, z_node, pv0
---
>   USE mcn, ONLY: x_node, y_node, z_node, pv0, volume
21c21
<   CHARACTER(LEN=80) :: ident_string='$Id: phast_root.F90,v 1.1 2009/05/07 19:46:55 klkipp Exp $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: phast_root.F90,v 1.2 2010/03/05 21:51:23 klkipp Exp $'
59c59,61
<             x_node, y_node, z_node, cnvtmi, transient_fresur, steady_flow, pv0, rebalance_method_f)
---
>             x_node, y_node, z_node, cnvtmi, transient_fresur, steady_flow, pv0, rebalance_method_f, volume, &
>             exchange_units, surface_units, ssassemblage_units, &
> 			ppassemblage_units, gasphase_units, kinetics_units)
63c65,68
<         CALL distribute_initial_conditions(indx_sol1_ic, indx_sol2_ic, ic_mxfrac)
---
>         CALL distribute_initial_conditions(indx_sol1_ic, indx_sol2_ic, ic_mxfrac,&
>                 exchange_units, surface_units, ssassemblage_units,&
>                 ppassemblage_units, gasphase_units, kinetics_units,&
>                 pv0, volume)
100c105
<            print_restart_flag, pv, pv0, steady_flow)
---
>            print_restart_flag, pv, pv0, steady_flow, volume)
172c177
<                 print_restart%print_flag_integer, pv, pv0, steady_flow)
---
>                 print_restart%print_flag_integer, pv, pv0, steady_flow, volume)

Property changes on: phast_root.F90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: phast_slave.F90
===================================================================
7c7
<   USE mcn, ONLY: x_node, y_node, z_node, pv0
---
>   USE mcn, ONLY: x_node, y_node, z_node, pv0, volume
22c22
<   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.1 2009/05/07 19:46:55 klkipp Exp $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.3 2010/03/05 21:51:23 klkipp Exp $'
27a28
>   !call mysleep(mpi_myself*100)
38,39c39,40
< !  time_phreeqc = 0.d0  
<   time_phreeqc = time
---
>   time_phreeqc = 0.d0  
> !  time_phreeqc = time
47c48,51
<           x_node, y_node, z_node, cnvtmi, transient_fresur, steady_flow, pv0, rebalance_method_f)
---
>           x_node, y_node, z_node, cnvtmi, transient_fresur, steady_flow, pv0, &
>           rebalance_method_f, volume, &
>           exchange_units, surface_units, ssassemblage_units, &
> 		  ppassemblage_units, gasphase_units, kinetics_units)
49c53,56
<      CALL distribute_initial_conditions(indx_sol1_ic, indx_sol2_ic, ic_mxfrac)
---
>      CALL distribute_initial_conditions(indx_sol1_ic, indx_sol2_ic, ic_mxfrac,&
>                 exchange_units, surface_units, ssassemblage_units,&
>                 ppassemblage_units, gasphase_units, kinetics_units,&
>                 pv0, volume)
60c67
<            print_restart_flag, pv, pv0, steady_flow)
---
>            print_restart_flag, pv, pv0, steady_flow, volume)
67c74
<                 print_restart%print_flag_integer, pv, pv0, steady_flow)
---
>                 print_restart%print_flag_integer, pv, pv0, steady_flow, volume)
92c99
<   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.1 2009/05/07 19:46:55 klkipp Exp $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.3 2010/03/05 21:51:23 klkipp Exp $'
114c121
<        ibc(nxyz), pv0(nxyz), pv(nxyz), &
---
>        ibc(nxyz), pv0(nxyz), pv(nxyz), volume(nxyz), &
144a152
>   ntprzf_heads = 0
177c185
< !!$  USE mcp
---
>   USE mcp
192c200
<   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.1 2009/05/07 19:46:55 klkipp Exp $'
---
>   CHARACTER(LEN=80) :: ident_string='$Id: phast_slave.F90,v 1.3 2010/03/05 21:51:23 klkipp Exp $'
196c204,205
<   CLOSE(fuins,STATUS='DELETE')  
---
>   !CLOSE(fuins,STATUS='DELETE')  
>   CALL MYCLOSE(fuins,'DELETE')  
198,238c207
< !!$  st(furde) = 'delete'
< !!$  if(errexi .or. errexe) st(furde) = 'keep'
<   ! ... delete file 'fuplt' if no plot data written
<   st(fuplt) = 'delete'  
<   IF(solute .AND. ntprtem > 0) st(fuplt) = 'keep  '
<   ! ... delete file 'fuorst' if no restart records written
<   st(fuorst) = 'delete'  
<   IF(nrsttp > 0) st(fuorst) = 'keep  '  
<   ! ... delete file 'fupmap', file 'fupmp2', and file 'fuvmap'
<   ! ...      if no screen or plotter map data written
<   st(fupmap) = 'delete'  
<   st(fupmp2) = 'delete'  
<   st(fuvmap) = 'delete'  
<   st(fuich) = 'delete'
< !!$  ! ... delete file 'fuich' if no initial condition head map data written
< !!$  st(fuich) = 'keep  '  
< !!$  if(.not.prtichead) st(fuich) = 'delete'  
<   ! ... close and delete file 'fupzon' if no zone map data written
<   st(fupzon) = 'delete'  
< !!$  if(pltzon) st(fupzon) = 'keep '  
<   st(fulp) = 'keep '
<   st(fup) = 'delete'  
<   IF(ntprp > 0) st(fup) = 'keep  '  
<   st(fuc) = 'delete'  
<   IF(ntprc > 0 .AND. solute) st(fuc) = 'keep  '  
<   st(fuvel) = 'delete'  
<   IF(ntprvel > 0) st(fuvel) = 'keep  '  
<   st(fuwel) = 'delete'  
<   IF(ntprwel > 0) st(fuwel) = 'keep  '  
<   st(fubal) = 'delete'  
<   IF(ntprgfb > 0) st(fubal) = 'keep  '  
<   st(fukd) = 'delete'  
<   IF(ntprkd > 0 .OR. prt_kd) st(fukd) = 'keep  '  
<   st(fubcf) = 'delete'  
<   IF(ntprbcf > 0) st(fubcf) = 'keep  '  
<   st(fuzf) = 'delete'  
<   IF(ntprzf > 0) st(fuzf) = 'keep  '  
<   st(fuzf_tsv) = 'delete'  
<   IF(ntprzf_tsv > 0) st(fuzf) = 'keep  '  
< !!$  st(fut) = 'delete'  
< #if defined(MERGE_FILES)
---
> 
240d208
< #endif
242,260c210,251
<   IF(print_rde) CLOSE(furde,status='keep')  
<   CLOSE(fuorst, status = st(fuorst))  
<   CLOSE(fulp, status = st(fulp))  
<   CLOSE(fup, status = st(fup))  
<   CLOSE(fuc, status = st(fuc))  
<   CLOSE(fuvel, status = st(fuvel))  
<   CLOSE(fuwel, status = st(fuwel))  
<   CLOSE(fubal, status = st(fubal))  
<   CLOSE(fukd, status = st(fukd))  
<   CLOSE(fubcf, status = st(fubcf))  
<   CLOSE(fuzf, status = st(fuzf))  
<   CLOSE(fuzf_tsv, status = st(fuzf_tsv))
<   CLOSE(fuplt, status = st(fuplt))  
<   CLOSE(fupmap, status = st(fupmap))  
<   CLOSE(fupmp2, status = st(fupmp2))  
<   CLOSE(fuvmap, status = st(fuvmap))  
< !!$  close(fupzon, status = st(fupzon))  
< !!$  close(fubnfr, status = st(fubcf))  
<   CLOSE(fuich, status = st(fuich))
---
> !  IF(print_rde) CLOSE(furde,status='delete')  
> !  CLOSE(fuorst, status = st(fuorst))  
> !  CLOSE(fulp, status = st(fulp))  
> !  CLOSE(fup, status = st(fup)) 
> !  CLOSE(fuwt, status = st(fuwt)) 
> !  CLOSE(fuc, status = st(fuc))  
> !  CLOSE(fuvel, status = st(fuvel))  
> !  CLOSE(fuwel, status = st(fuwel))  
> !  CLOSE(fubal, status = st(fubal))  
> !  CLOSE(fukd, status = st(fukd))  
> !  CLOSE(fubcf, status = st(fubcf))  
> !  CLOSE(fuzf, status = st(fuzf))  
> !  CLOSE(fuzf_tsv, status = st(fuzf_tsv))
> !  CLOSE(fuplt, status = st(fuplt))  
> !  CLOSE(fupmap, status = st(fupmap))  
> !  CLOSE(fupmp2, status = st(fupmp2))
> !  CLOSE(fupmp3, status = st(fupmp2))  
> !  CLOSE(fuvmap, status = st(fuvmap))  
> !!!$  close(fupzon, status = st(fupzon))  
> !!!$  close(fubnfr, status = st(fubcf))  
> !  CLOSE(fuich, status = st(fuich))
> 
>   IF(print_rde) CALL MYCLOSE(furde, 'delete')  
>   CALL MYCLOSE(fuorst, st(fuorst))  
>   CALL MYCLOSE(fulp, st(fulp))  
>   CALL MYCLOSE(fup, st(fup)) 
>   CALL MYCLOSE(fuwt, st(fuwt)) 
>   CALL MYCLOSE(fuc, st(fuc))  
>   CALL MYCLOSE(fuvel, st(fuvel))  
>   CALL MYCLOSE(fuwel, st(fuwel))  
>   CALL MYCLOSE(fubal, st(fubal))  
>   CALL MYCLOSE(fukd, st(fukd))  
>   CALL MYCLOSE(fubcf, st(fubcf))  
>   CALL MYCLOSE(fuzf, st(fuzf))  
>   CALL MYCLOSE(fuzf_tsv, st(fuzf_tsv))
>   CALL MYCLOSE(fuplt, st(fuplt))  
>   CALL MYCLOSE(fupmap, st(fupmap))  
>   CALL MYCLOSE(fupmp2, st(fupmp2))
>   CALL MYCLOSE(fupmp3, st(fupmp2))  
>   CALL MYCLOSE(fuvmap, st(fuvmap))  
>   CALL MYCLOSE(fuich, st(fuich))
> 
267c258
<     ibc, &
---
>     ibc, pv0, pv, volume, &

Property changes on: phast_slave.F90
___________________________________________________________________
Added: svn:eol-style
   + native

Index: terminate_phast.F90
===================================================================
23a24,26
>   REAL(KIND=kdp) :: dummy
>   INTEGER :: idummy
>   
31,32c34,36
<      CALL equilibrate(c,nxyz,0,x_node,y_node,z_node,time,deltim,prslmi,cnvtmi,  &
<        frac, iprint_chem, iprint_xyz, 0, stop_msg, 0, 0)
---
>      CALL equilibrate(c,nxyz,idummy,x_node,y_node,z_node,time,deltim,prslmi,cnvtmi,  &
>        frac, iprint_chem, iprint_xyz, idummy, stop_msg, &
>        idummy, dummy, idummy, dummy, dummy, idummy, dummy)
