Index: phast_slave.F90
===================================================================
--- phast_slave.F90	(revision 5000)
+++ phast_slave.F90	(revision 6719)
@@ -64,15 +64,17 @@
      CALL equilibrate(c,nxyz,prcphrqi,x_node,y_node,z_node,time_phreeqc,deltim_dummy,prslmi,  &
            cnvtmi,frac_icchem,iprint_chem,iprint_xyz, &
            prf_chem_phrqi,stop_msg,prhdfci,rebalance_fraction_f, &
-           print_restart_flag, pv, pv0, steady_flow, volume)
+           print_restart_flag, pv, pv0, steady_flow, volume, przf_xyzt)
+     CALL zone_flow_write_chem(mpi_tasks, mpi_myself, .true.)
      stop_msg = 0
      deltim_dummy = 0._kdp
      ! ... The transient loop
      DO
            CALL equilibrate(c,nxyz,prcphrqi,x_node,y_node,z_node,time,deltim,prslmi,cnvtmi,  &
                 frac,iprint_chem,iprint_xyz,prf_chem_phrqi,stop_msg,prhdfci,rebalance_fraction_f, &
-                print_restart%print_flag_integer, pv, pv0, steady_flow, volume)
+                print_restart%print_flag_integer, pv, pv0, steady_flow, volume, przf_xyzt)
            IF (stop_msg == 1) EXIT
+           CALL zone_flow_write_chem(mpi_tasks, mpi_myself, .false.)
      ENDDO
   ENDIF
   CALL slave_closef
@@ -149,7 +151,7 @@
   ntprgfb = 0
   ntprzf = 0
   ntprzf_tsv = 0
-  ntprzf_heads = 0
+  ntprzf_xyzt = 0
   ntprkd = 0
   ntprmapcomp = 0
   ntprmaphead = 0
Index: modules.f90
===================================================================
--- modules.f90	(revision 5000)
+++ modules.f90	(revision 6719)
@@ -7,7 +7,8 @@
   INTEGER, PARAMETER :: fuins=15, fulp=16, fuplt=7, fuorst=8, fuirst=9, fuinc=10, furde=11, &
        fupmap=13, fuvmap=14, fup=21, fut=29, fuc=22, fuvel=23, fud=30, fuvs=31, fuwel=24, &
        fubal=25, fukd=26, fubcf=27, fuclog=28, fubnfr=32, fupmp2=33, fupzon=34, fuich=35,  &
-       fuzf=36, fuzf_tsv=37, fuwt=38, fupmp3=39, fuzf_heads=40
+       fuzf=36, fuzf_tsv=37, fuwt=38, fupmp3=39, fuzf_heads=40, fuzf_chem_xyzt = 41, &
+       fuzf_chem_raw = 42
   LOGICAL :: print_rde=.FALSE.
 END MODULE f_units
 
@@ -125,6 +126,7 @@
   TYPE(zone_bc_cells), DIMENSION(:,:), ALLOCATABLE :: lnk_bc2zon
   TYPE(well_segments), DIMENSION(:), ALLOCATABLE :: seg_well
   CHARACTER(LEN=80), DIMENSION(:), ALLOCATABLE :: zone_title
+  INTEGER, DIMENSION(:), ALLOCATABLE :: zone_number
   CHARACTER(LEN=140), DIMENSION(:), ALLOCATABLE :: zone_filename_heads
   LOGICAL, DIMENSION(:), ALLOCATABLE :: zone_write_heads
   INTEGER :: num_flo_zones
@@ -146,19 +148,19 @@
   INTEGER :: iprptc, ltcom, maxitn, ntsfal, orenpr, &
        slmeth, tmunit
   REAL(KIND=kdp) :: pribcf, pricpd, pridv,  &
-       prihdf_head, prihdf_vel, prihdf_conc,  &
+       prihdf_head, prihdf_vel, prihdf_conc, prihdf_intermediate, &
        prigfb, prikd, primapcomp, primaphead, primapv, primin, prip, prit, pric,  &
        pricphrq, priforce_chem_phrq, prislm, pri_well_timser, &
        privel, priwel, pri_zf, pri_zf_tsv
   REAL(KIND=kdp) :: timprbcf, timprcpd, timprdv,  &
-       timprhdfh, timprhdfv, timprhdfcph,  &
+       timprhdfh, timprhdfv, timprhdfcph, timprhdfi, &
        timprgfb, timprkd, timprmapc, timprmaph, timprmapv, timprp, timprc, timprcphrq,  &
        timprfchem, timprslm, timprtem, &
        timprvel, timprwel, timprzf, timprzf_tsv, timprtnxt
   ! print control flags for zone_flow heads + print_zone_flows_heads    
-  REAL (KIND=kdp) :: pri_zf_heads, timprzf_heads
-  LOGICAL :: przf_heads=.false.
-  INTEGER :: ntprzf_heads
+  REAL (KIND=kdp) :: pri_zf_xyzt, timprzf_xyzt
+  LOGICAL :: przf_xyzt=.false.
+  INTEGER :: ntprzf_xyzt
   LOGICAL :: argrid, comopt, errexe, errexi, ichwt, ichydp, pltzon, prtbc, prtdv, prtfp,  &
        prtic, prtichead=.FALSE., prtpmp, prtslm, prtwel, prt_kd, prt_bc, &
        prtic_c, prtic_mapc, prtic_p, prtic_maphead, prtic_conc, prtic_force_chem,  &
@@ -174,10 +176,10 @@
   LOGICAL :: oldstyle_head_file=.FALSE.
   LOGICAL :: prslm=.FALSE., prkd=.FALSE., prp=.FALSE., prc=.FALSE., prcphrq=.FALSE., &
        prf_chem_phrq=.FALSE., prvel=.FALSE., prgfb=.FALSE., prbcf=.FALSE., przf=.FALSE.,  &
-       przf_tsv=.FALSE., prwel=.FALSE.,  &
+       przf_tsv=.FALSE., prwel=.FALSE., prhdfi=.FALSE., &
        prhdfh=.FALSE., prhdfv=.FALSE., prhdfc=.FALSE., prmapc=.FALSE., prmaph=.FALSE., &
        prmapv=.FALSE., prtem=.FALSE., prcpd=.FALSE.
-  INTEGER :: prcphrqi, prf_chem_phrqi, prslmi, prhdfci, prhdfhi, prhdfvi
+  INTEGER :: prcphrqi, prf_chem_phrqi, prslmi, prhdfci, prhdfhi, prhdfvi, prhdfii
   INTEGER :: ntprbcf, ntprcpd, ntprhdfv, ntprhdfh, ntprgfb, ntprkd, ntprmapcomp,   &
        ntprmaphead, ntprmapv, ntprp, ntprzf, ntprzf_tsv, &
        ntprc, ntprvel, ntprwel, ntprtem
Index: write5_ss_flow.f90
===================================================================
--- write5_ss_flow.f90	(revision 5000)
+++ write5_ss_flow.f90	(revision 6719)
@@ -51,7 +51,7 @@
   prgfb=.FALSE.
   przf = .FALSE.
   przf_tsv = .FALSE.
-  przf_heads = .FALSE.
+  przf_xyzt = .FALSE.
   prbcf=.FALSE.
   prwel=.FALSE.
   prslm=.FALSE.
@@ -85,9 +85,9 @@
      IF(ABS(pri_zf_tsv) > 0._kdp) THEN
         IF(converge_ss) przf_tsv=.TRUE.
      END IF
-     IF(ABS(pri_zf_heads) > 0._kdp) THEN
-        IF(converge_ss) przf_heads=.TRUE.
-     END IF            
+     IF(ABS(pri_zf_xyzt) > 0._kdp) THEN
+        IF(converge_ss) przf_xyzt=.TRUE.
+     END IF   
      ! ... B.C. flow rates
      IF(ABS(pribcf) > 0._kdp) THEN
         IF(converge_ss) prbcf=.TRUE.
@@ -253,7 +253,7 @@
      WRITE(fuzf,2001)  '*** Output at End of Steady State Iteration No. ', itime,' ***'
      WRITE(fuzf,2002) 'Time '//dots,cnvtmi*time,'('//TRIM(unittm)//')'
      DO izn=1,num_flo_zones
-        WRITE(fuzf,2310) '*** Zonal Flow Summary, zone:',izn,' ***',  &
+        WRITE(fuzf,2310) '*** Zonal Flow Summary, zone:',zone_number(izn),' ***',  &
              zone_title(izn), 'Current Time Step','Rates'
 2310    FORMAT(/tr40,a,i4,a,/tr10,a/tr25,a,tr25,a)
         WRITE(fuzf,2311) 'Fluid inflow '//dots,cnvmfi*qfzoni(izn),  &
@@ -299,7 +299,7 @@
   IF(przf_tsv) THEN
      ! ... Zonal flow rates to tab separated file, fuzf_tsv
      DO izn=1,num_flo_zones
-        WRITE(fuzf_tsv,2502) cnvtmi*time,achar(9),izn,achar(9),'Water',achar(9),  &
+        WRITE(fuzf_tsv,2502) cnvtmi*time,achar(9),zone_number(izn),achar(9),'Water',achar(9),  &
              cnvmfi*qfzoni(izn),achar(9),cnvmfi*qfzonp(izn),achar(9),  &
              cnvmfi*qfzoni_int(izn),achar(9),cnvmfi*qfzonp_int(izn),achar(9),  &
              cnvmfi*qfzoni_sbc(izn),achar(9),cnvmfi*qfzonp_sbc(izn),achar(9),  &
@@ -312,11 +312,16 @@
      ENDDO
      ntprzf_tsv = ntprzf_tsv+1
   END IF
-  IF(przf_heads) THEN  
-     ! ... Zonal heads to file, fuzf_heads
-     CALL zone_flow_write_heads
-     ntprzf_heads = ntprzf_heads+1
-  END IF  
+  !IF(przf_xyzt) THEN  
+  !   ! ... Zonal heads to file, fuzf_heads
+  !   CALL zone_flow_write_heads
+  !   ntprzf_xyzt = ntprzf_xyzt+1
+  !END IF
+  ! move to phast_root and phast_slave
+  !IF(przf_xyzt .and. solute) THEN  
+  !   ! ... Zonal chem to file, fuzf_chem_xyzt and .chem.bc
+  !   CALL zone_flow_write_chem
+  !END IF 
   IF(prwel) THEN
      nsa = MAX(ns,1)
      ALLOCATE (chu10a(nsa), chu11a(nsa), &
Index: wbbal.f90
===================================================================
--- wbbal.f90	(revision 5000)
+++ wbbal.f90	(revision 6719)
@@ -92,6 +92,10 @@
               !                     UQHW=UQHW-QHLYR(IWEL,K)
               !                     TWK(IWEL,K)=TOFEP(EHWK(IWEL,K),PWK(IWEL,K),ERFLG)
               !                  ENDIF
+              if (Ks .eq. 1 .and. ns .ge. 1) then
+                STOP "Error in well calculation. Be sure all wells have at least a small pumping/injection rate."
+              endif
+
               do 14 iis = 1, ns  
                  CWK( IWEL, Ks, iis) = CWK( IWEL, Ks - 1, iis)  
                  QSLYR( IWEL, Ks, iis) = QFLYR( IWEL, Ks) * CWK( &
Index: read3.f90
===================================================================
--- read3.f90	(revision 5000)
+++ read3.f90	(revision 6719)
@@ -267,24 +267,25 @@
   prigfb = -prigfb
   pribcf = -pribcf
   priwel = -priwel
-  READ(fuins,*) prihdf_conc, prihdf_head, prihdf_vel
-  IF (print_rde) WRITE(furde,8108) 'prihdf_conc, prihdf_head, prihdf_vel, [3.8.2]',  &
-       prihdf_conc, prihdf_head, prihdf_vel
+  READ(fuins,*) prihdf_conc, prihdf_head, prihdf_vel, prihdf_intermediate
+  IF (print_rde) WRITE(furde,8108) 'prihdf_conc, prihdf_head, prihdf_vel, prihdf_intermediate [3.8.2]',  &
+       prihdf_conc, prihdf_head, prihdf_vel, prihdf_intermediate
 8108 FORMAT(tr5,A/tr5,11F10.2)
   prihdf_conc = -prihdf_conc
   prihdf_head = -prihdf_head
   prihdf_vel = -prihdf_vel
+  prihdf_intermediate = -prihdf_intermediate
   READ(fuins,*) prtichead
   IF (print_rde) WRITE(furde,8208) 'prtichead, [3.8.2.1]', prtichead
 8208 FORMAT(tr5,A/tr5,l5)
   if(num_flo_zones > 0) then
-     READ(fuins,*) pri_zf, pri_zf_tsv, pri_zf_heads
-     IF (print_rde) WRITE(furde,8111) 'pri_zf, pri_zf_tsv, pri_zf_heads[3.8.2.2]', &
-        pri_zf, pri_zf_tsv, pri_zf_heads
+     READ(fuins,*) pri_zf, pri_zf_tsv, pri_zf_xyzt
+     IF (print_rde) WRITE(furde,8111) 'pri_zf, pri_zf_tsv, pri_zf_xyzt[3.8.2.2]', &
+        pri_zf, pri_zf_tsv, pri_zf_xyzt
      ! ... ***special patch
      pri_zf = -pri_zf
      pri_zf_tsv = -pri_zf_tsv
-     pri_zf_heads = -pri_zf_heads
+     pri_zf_xyzt = -pri_zf_xyzt
   end if
   READ(fuins,*) chkptd,pricpd,savldo
   IF (print_rde) WRITE(furde,8010) 'CHKPTD,PRICPD,SAVLDO [3.8.3]',  &
Index: gcgris.f90
===================================================================
--- gcgris.f90	(revision 5000)
+++ gcgris.f90	(revision 6719)
@@ -212,6 +212,16 @@
   CALL abmult(w,xx_b)
   CALL vpsv(rhs_r,rhs_r,w,-1.0_kdp,nrn)
   ! ... Set RHS_black equal to X_black
-  rhs_b = xx_b
+!  This construct uses a lot of stack for some reason
+!  Causes stack overflow for large problem  
+!  rhs_b = xx_b
+! Hopefully, this construct is equivalent,
+! Avoids stack overflow
+!  do i = 1, nxyz - nrnp1 + 1
+!    rhs_b(i) = xx_b(i)
+!    enddo
+  do i = nrnp1, nxyz
+    rhs(i) = xx(i)
+    enddo
   NULLIFY(apv, bpv, bpvlp, bpvj)
 END SUBROUTINE gcgris
Index: write2_2.f90
===================================================================
--- write2_2.f90	(revision 5000)
+++ write2_2.f90	(revision 6719)
@@ -85,7 +85,7 @@
      IF(errexi) GO TO 390
      ! ... Print initial condition distributions and aquifer properties
      DO  m=1,nxyz
-        IF(ibc(m) == -1) THEN
+        IF(ibc(m) == -1.OR.frac(m) <= 0.0_kdp) THEN
            lprnt1(m)=-1
         ELSE
            lprnt1(m)=1
Index: hst.cxx
===================================================================
--- hst.cxx	(revision 5000)
+++ hst.cxx	(revision 6719)
@@ -3,6 +3,7 @@
 #ifdef USE_MPI
 #include <mpi.h>
 #endif
+#include <set>
 #include <fstream>
 #include <iostream>				// std::cout std::cerr
 #include "StorageBin.h"
@@ -21,6 +22,7 @@
 #include <vector>
 #include "KDtree/Point.h"
 #include "KDtree/KDtree.h"
+#include "Solution.h"
 
 
 extern int xsurface_save(int n_user);
@@ -38,7 +40,7 @@
 static int mpi_rebalance_load_per_cell(double *times_per_cell, double *frac,
 									   int transfer);
 #define MESSAGE_MAX_NUMBERS 1000
-#define MPI_MAX_TASKS 50
+//#define MPI_MAX_TASKS 50
 #include <time.h>
 int mpi_tasks;
 int mpi_myself;
@@ -52,8 +54,11 @@
 void *mpi_buffer;
 int mpi_buffer_position, mpi_max_buffer;
 LDBLE mpi_processor_test_time;
-int end_cells[MPI_MAX_TASKS][2];
-int number_cells[MPI_MAX_TASKS];
+//int end_cells[MPI_MAX_TASKS][2];
+std::vector<int> start_cell;
+std::vector<int> end_cell;
+//int number_cells[MPI_MAX_TASKS];
+//std::vector<int> number_cells_v;
 #define TIME
 #ifdef TIME
 LDBLE start_time, end_time, transport_time, transport_time_tot,
@@ -74,7 +79,7 @@
 							   int *print_out, int *print_hdf,
 							   double *rebalance_fraction_hst,
 							   int *print_restart, double *pv, double *pv0,
-							   int *steady_flow, double *volume);
+							   int *steady_flow, double *volume, int *przf_xyzt);
 #endif /* #ifdef USE_MPI */
 cxxStorageBin uzBin;
 cxxStorageBin szBin;
@@ -106,6 +111,7 @@
 #define SETUP_BOUNDARY_CONDITIONS        FC_FUNC_ (setup_boundary_conditions,     SETUP_BOUNDARY_CONDITIONS)
 #define WARNPRT_C                        FC_FUNC_ (warnprt_c,                     WARNPRT_C)
 #define UZ_INIT                          FC_FUNC_ (uz_init,                       UZ_INIT)
+#define WRITE_BC_RAW                     FC_FUNC_ (write_bc_raw,                  WRITE_BC_RAW)
 
 #else /* defined(FC_FUNC_) */
 
@@ -130,6 +136,7 @@
 #define SETUP_BOUNDARY_CONDITIONS setup_boundary_conditions
 #define WARNPRT_C warnprt_c
 #define UZ_INIT uz_init
+#define WRITE_BC_RAW write_bc_raw 
 #else
 #define CALCULATE_WELL_PH calculate_well_ph_
 #define COLLECT_FROM_NONROOT collect_from_nonroot_
@@ -151,6 +158,7 @@
 #define SETUP_BOUNDARY_CONDITIONS setup_boundary_conditions_
 #define WARNPRT_C warnprt_c_
 #define UZ_INIT uz_init_
+#define WRITE_BC_RAW write_bc_raw_
 #endif
 
 #endif /* defined(FC_FUNC_) */
@@ -188,7 +196,7 @@
 				int *printzone_xyz, int *print_out, int *stop_msg,
 				int *print_hdf, double *rebalance_fraction_hst,
 				int *print_restart, double *pv, double *pv0,
-				int *steady_flow, double *volume);
+				int *steady_flow, double *volume, int *przf_xyzt);
 /*  #endif                                                                             */
 	void
 	ERRPRT_C(char *err_str, long l);
@@ -222,6 +230,8 @@
 	UZ_INIT(int *transient_fresur);
 	void
 	WARNPRT_C(char *err_str, long l);
+	void
+	WRITE_BC_RAW(int *solution_list, int * bc_soln_count, int * solution_number, char *file_name, int file_name_l);
 }
 /* ---------------------------------------------------------------------- */
 void
@@ -260,7 +270,7 @@
 		free_model_allocs();
 		free_check_null(buffer);
 		free_check_null(activity_list);
-		free_check_null(forward);
+		free_check_null(forward1);
 		free_check_null(back);
 		//free_check_null(file_prefix);
 		free_check_null(old_frac);
@@ -476,7 +486,13 @@
 	{
 		output_msg(OUTPUT_ECHO, "Processing database file.\n");
 	}
+#if defined(MERGE_INCLUDE_FILES) 
+	set_cookie((std::ifstream *) db_cookie);
+	errors = read_database(istream_getc, db_cookie);
+	clear_cookie();
+#else
 	errors = read_database(getc_callback, db_cookie);
+#endif
 	if (errors != 0)
 	{
 		clean_up();
@@ -494,7 +510,13 @@
 	{
 		output_msg(OUTPUT_ECHO, "\nProcessing chemical data file.\n");
 	}
+#if defined(MERGE_INCLUDE_FILES) 
+	set_cookie((std::ifstream *)input_cookie);
+	errors = run_simulations(istream_getc, input_cookie);
+	clear_cookie();
+#else
 	errors = run_simulations(getc_callback, input_cookie);
+#endif
 	if (errors != 0)
 	{
 		clean_up();
@@ -905,7 +927,8 @@
 
 	for (i = 0; i < mpi_tasks; i++)
 	{
-		for (j = end_cells[i][0]; j <= end_cells[i][1]; j++)
+		//for (j = end_cells[i][0]; j <= end_cells[i][1]; j++)
+		for (j = start_cell[i]; j <= end_cell[i]; j++)
 		{
 			count_chem2task_number[random_list[j]] = i;
 		}
@@ -928,13 +951,23 @@
 	 *  Copy solution, exchange, surface, gas phase, kinetics, solid solution for each active cell.
 	 *  Does nothing if i < 0, i.e. values to be gotten from restart files
 	 */
+	size_t count_negative_porosity = 0;
 	for (k = 0; k < last_cell - first_cell + 1; k++)
 	{
 		j = sort_random_list[k];	/* j is count_chem number */
 		i = back[j].list[0];	/* i is ixyz number */
-		assert(forward[i] >= 0);
+		assert(forward1[i] >= 0);
 		assert (volume[i] > 0.0);
 		double porosity = pv0[i] / volume[i];
+		if (pv0[i] < 0 || volume[i] < 0)
+		{
+			sprintf(error_string, "Negative volume in cell %d: volume, %e\t initial volume, %e.",
+					i, volume[i], pv0[i]);
+			input_error++;
+			count_negative_porosity++;
+			error_msg(error_string, CONTINUE);
+			continue;
+		}
 		assert (porosity > 0.0);
 		double porosity_factor = (1.0 - porosity) / porosity;
 		system_cxxInitialize(i, j, initial_conditions1, initial_conditions2,
@@ -943,6 +976,13 @@
 			ppassemblage_units, gasphase_units, kinetics_units,
 			porosity_factor);
 	}
+	if (count_negative_porosity > 0)
+	{
+		sprintf(error_string, "Negative initial volumes may be due to initial head distribution.\n"
+			"Make initial heads greater than or equal to the elevation of the node for each cell.\n"
+			"Increase porosity, decrease specific storage, or use free surface boundary.");
+		error_msg(error_string, CONTINUE);
+	}
 	sort_random_list = (int *) free_check_null(sort_random_list);
 	/*
 	 * Only root reads restart files, then sends to appropriate processes
@@ -1326,14 +1366,24 @@
 	 *  Copy solution, exchange, surface, gas phase, kinetics, solid solution for each active cell.
 	 *  Does nothing for indexes less than 0 (i.e. restart files)
 	 */
+	size_t count_negative_porosity = 0;
 	for (i = 0; i < ixyz; i++)
 	{							/* i is ixyz number */
-		j = forward[i];			/* j is count_chem number */
+		j = forward1[i];			/* j is count_chem number */
 		if (j < 0)
 			continue;
-		assert(forward[i] >= 0);
+		assert(forward1[i] >= 0);
 		assert (volume[i] > 0.0);
 		double porosity = pv0[i] / volume[i];
+		if (pv0[i] < 0 || volume[i] < 0)
+		{
+			sprintf(error_string, "Negative volume in cell %d: volume, %e\t initial volume, %e.",
+					i, volume[i], pv0[i]);
+			input_error++;
+			count_negative_porosity++;
+			error_msg(error_string, CONTINUE);
+			continue;
+		}
 		assert (porosity > 0.0);
 		double porosity_factor = (1.0 - porosity) / porosity;
 		system_cxxInitialize(i, j, initial_conditions1, initial_conditions2,
@@ -1342,6 +1392,13 @@
 			ppassemblage_units, gasphase_units, kinetics_units,
 			porosity_factor);
 	}
+	if (count_negative_porosity > 0)
+	{
+		sprintf(error_string, "Negative initial volumes may be due to initial head distribution.\n"
+			"Make initial heads greater than or equal to the elevation of the node for each cell.\n"
+			"Increase porosity, decrease specific storage, or use free surface boundary.");
+		error_msg(error_string, CONTINUE);
+	}
 	/*
 	 * Read any restart files
 	 */
@@ -1651,7 +1708,7 @@
 				   double *cnvtmi, double *frac, int *printzone_chem,
 				   int *printzone_xyz, int *print_out, int *print_hdf,
 				   double *rebalance_fraction_hst, int *print_restart,
-				   double *pv, double *pv0, int *steady_flow, double *volume)
+				   double *pv, double *pv0, int *steady_flow, double *volume, int *przf_xyzt)
 /* ---------------------------------------------------------------------- */
 {
 /*
@@ -1726,6 +1783,7 @@
 
 	rate_sim_time_start = *time_hst - *time_step_hst;
 	rate_sim_time_end = *time_hst;
+	rate_cnvtmi = *cnvtmi;
 	initial_total_time = 0;
 	// free all c structures
 	reinitialize();
@@ -1930,7 +1988,7 @@
 			double *cnvtmi, double *frac, int *printzone_chem,
 			int *printzone_xyz, int *print_out, int *stop_msg, int *print_hdf,
 			double *rebalance_fraction_hst, int *print_restart, double *pv,
-			double *pv0, int *steady_flow, double *volume)
+			double *pv0, int *steady_flow, double *volume, int *przf_xyzt)
 /* ---------------------------------------------------------------------- */
 {
 #ifndef USE_MPI
@@ -1941,7 +1999,7 @@
 						   time_hst, time_step_hst, prslm, cnvtmi,
 						   frac, printzone_chem, printzone_xyz, print_out,
 						   print_hdf, rebalance_fraction_hst, print_restart,
-						   pv, pv0, steady_flow, volume);
+						   pv, pv0, steady_flow, volume, przf_xyzt);
 	}
 	return;
 #else /* #ifndef USE_MPI */
@@ -2048,7 +2106,7 @@
 	distribute_from_root(fraction, dim, print_sel,
 						 time_hst, time_step_hst, prslm,
 						 frac, printzone_chem, printzone_xyz,
-						 print_out, print_hdf, print_restart, pv, pv0);
+						 print_out, print_hdf, print_restart, pv, pv0, przf_xyzt);
 #ifdef TIME
 	end_time = (LDBLE) MPI_Wtime();
 	time_distribute = end_time - start_time;
@@ -2107,6 +2165,7 @@
 
 	rate_sim_time_start = *time_hst - *time_step_hst;
 	rate_sim_time_end = *time_hst;
+	rate_cnvtmi = *cnvtmi;
 	initial_total_time = 0;
 	/*
 	 *  Sort list for processor
@@ -2468,8 +2527,8 @@
 /*
  *   malloc space
  */
-	forward = (int *) PHRQ_malloc((size_t) ixyz * sizeof(int));
-	if (forward == NULL)
+	forward1 = (int *) PHRQ_malloc((size_t) ixyz * sizeof(int));
+	if (forward1 == NULL)
 		malloc_error();
 	back =
 		(struct back_list *) PHRQ_malloc((size_t) count_chem *
@@ -2489,13 +2548,13 @@
 			if (initial_conditions[7 * i] >= 0
 				|| initial_conditions[7 * i] <= -100)
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				n++;
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2514,14 +2573,14 @@
 				&& (initial_conditions[7 * i] >= 0
 					|| initial_conditions[7 * i] <= -100))
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + ixy;
 				n++;
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2540,14 +2599,14 @@
 				&& (initial_conditions[7 * i] >= 0
 					|| initial_conditions[7 * i] <= -100))
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + ix;
 				n++;
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2573,14 +2632,14 @@
 				&& (initial_conditions[7 * i] >= 0
 					|| initial_conditions[7 * i] <= -100))
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + 1;
 				n++;
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2618,7 +2677,7 @@
 			n_to_ijk(i, &ii, &jj, &kk);
 			if (jj == 0 && kk == 0)
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + ix;
 				back[n].list[2] = i + ixy;
@@ -2627,7 +2686,7 @@
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2665,7 +2724,7 @@
 			n_to_ijk(i, &ii, &jj, &kk);
 			if (ii == 0 && kk == 0)
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + 1;
 				back[n].list[2] = i + ixy;
@@ -2674,7 +2733,7 @@
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2699,7 +2758,7 @@
 			n_to_ijk(i, &ii, &jj, &kk);
 			if (ii == 0 && jj == 0)
 			{
-				forward[i] = n;
+				forward1[i] = n;
 				back[n].list[0] = i;
 				back[n].list[1] = i + 1;
 				back[n].list[2] = i + ix;
@@ -2708,7 +2767,7 @@
 			}
 			else
 			{
-				forward[i] = -1;
+				forward1[i] = -1;
 			}
 		}
 		count_chem = n;
@@ -2912,13 +2971,17 @@
 	{
 		if (i < num_n_tasks)
 		{
-			end_cells[i][0] = i * n;
-			end_cells[i][1] = end_cells[i][0] + n - 1;
+			//end_cells[i][0] = i * n;
+			start_cell.push_back(i * n);
+			//end_cells[i][1] = end_cells[i][0] + n - 1;
+			end_cell.push_back(start_cell[i] + n - 1);
 		}
 		else
 		{
-			end_cells[i][0] = (num_n_tasks * n) + (i - num_n_tasks) * (n + 1);
-			end_cells[i][1] = end_cells[i][0] + n;
+			//end_cells[i][0] = (num_n_tasks * n) + (i - num_n_tasks) * (n + 1);
+			start_cell.push_back((num_n_tasks * n) + (i - num_n_tasks) * (n + 1));
+			//end_cells[i][1] = end_cells[i][0] + n;
+			end_cell.push_back(start_cell[i] + n);
 		}
 	}
 	/*
@@ -2967,15 +3030,15 @@
 	mpi_rebalance_load(time_exec, frac, FALSE);
 	return (OK);
 }
-
 /* ---------------------------------------------------------------------- */
 int
 mpi_rebalance_load(double time_per_cell, double *frac, int transfer)
 /* ---------------------------------------------------------------------- */
 {
 #include <time.h>
-	double
-		recv_buffer[MPI_MAX_TASKS + 1];
+	//double
+		//recv_buffer[MPI_MAX_TASKS + 1];
+	double *recv_buffer = (double *) PHRQ_malloc(size_t ((mpi_tasks + 1) * sizeof(double)));
 	LDBLE
 		total;
 	int
@@ -2984,10 +3047,18 @@
 		k,
 		min_cell,
 		max_cell;
-	int
-		end_cells_new[MPI_MAX_TASKS][2];
-	int
-		cells[MPI_MAX_TASKS];
+	//int
+		//end_cells_new[MPI_MAX_TASKS][2];
+		std::vector<int> start_cell_new;
+		std::vector<int> end_cell_new;
+	for (i = 0; i < mpi_tasks; i++)
+	{
+		start_cell_new.push_back(0);
+		end_cell_new.push_back(0);
+	}
+	//int
+		//cells[MPI_MAX_TASKS];
+		std::vector<int> cells_v;
 	LDBLE
 		new_n,
 		min_time,
@@ -3054,10 +3125,6 @@
 		}
 	}
 	/*
-	   MPI_Bcast(&error, mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
-	   if (error == TRUE) return(FALSE);
-	 */
-	/*
 	 *  Set first and last cells
 	 */
 	if (mpi_myself == 0)
@@ -3072,7 +3139,8 @@
 			n = (int) floor(new_n * recv_buffer[0] / recv_buffer[i]);
 			if (n < 1)
 				n = 1;
-			cells[i] = n;
+			//cells[i] = n;
+			cells_v.push_back(n);
 			total_cells += n;
 		}
 		/*
@@ -3084,16 +3152,16 @@
 			for (j = 0; j < diff_cells; j++)
 			{
 				min_cell = 0;
-				min_time = (cells[0] + 1) * recv_buffer[0];
+				min_time = (cells_v[0] + 1) * recv_buffer[0];
 				for (i = 1; i < mpi_tasks; i++)
 				{
-					if ((cells[i] + 1) * recv_buffer[i] < min_time)
+					if ((cells_v[i] + 1) * recv_buffer[i] < min_time)
 					{
 						min_cell = i;
-						min_time = (cells[i] + 1) * recv_buffer[i];
+						min_time = (cells_v[i] + 1) * recv_buffer[i];
 					}
 				}
-				cells[min_cell] += 1;
+				cells_v[min_cell] += 1;
 			}
 		}
 		else if (diff_cells < 0)
@@ -3104,16 +3172,16 @@
 				max_time = 0;
 				for (i = 0; i < mpi_tasks; i++)
 				{
-					if (cells[i] > 1)
+					if (cells_v[i] > 1)
 					{
-						if ((cells[i] - 1) * recv_buffer[i] > max_time)
+						if ((cells_v[i] - 1) * recv_buffer[i] > max_time)
 						{
 							max_cell = i;
-							max_time = (cells[i] - 1) * recv_buffer[i];
+							max_time = (cells_v[i] - 1) * recv_buffer[i];
 						}
 					}
 				}
-				cells[max_cell] -= 1;
+				cells_v[max_cell] -= 1;
 			}
 		}
 		/*
@@ -3122,23 +3190,29 @@
 		last = -1;
 		for (i = 0; i < mpi_tasks; i++)
 		{
-			end_cells_new[i][0] = last + 1;
-			end_cells_new[i][1] = end_cells_new[i][0] + cells[i] - 1;
-			last = end_cells_new[i][1];
+			//end_cells_new[i][0] = last + 1;
+			start_cell_new[i] = last + 1;
+			//end_cells_new[i][1] = end_cells_new[i][0] + cells[i] - 1;
+			end_cell_new[i] = start_cell_new[i] + cells_v[i] - 1;
+			//last = end_cells_new[i][1];
+			last = end_cell_new[i];
 		}
 		/*
 		 *  Check that all cells are distributed
 		 */
-		if (end_cells_new[mpi_tasks - 1][1] != count_cells - 1)
+		//if (end_cells_new[mpi_tasks - 1][1] != count_cells - 1)
+		if (end_cell_new[mpi_tasks - 1] != count_cells - 1)
 		{
 			output_msg(OUTPUT_STDERR,
 					   "Failed: %d, count_cells %d, last cell %d\n",
 					   diff_cells, count_cells,
-					   end_cells_new[mpi_tasks - 1][1]);
+					   //end_cells_new[mpi_tasks - 1][1]);
+					   end_cell_new[mpi_tasks - 1]);
 			for (i = 0; i < mpi_tasks; i++)
 			{
 				output_msg(OUTPUT_STDERR, "%d: first %d\tlast %d\n", i,
-						   end_cells_new[i][0], end_cells_new[i][1]);
+						   //end_cells_new[i][0], end_cells_new[i][1]);
+						   start_cell_new[i], end_cell_new[i]);
 			}
 			error_msg("Failed to redistribute cells.", STOP);
 		}
@@ -3149,10 +3223,11 @@
 		max_new = 0.0;
 		for (i = 0; i < mpi_tasks; i++)
 		{
-			t = cells[i] * recv_buffer[i];
+			t = cells_v[i] * recv_buffer[i];
 			if (t > max_new)
 				max_new = t;
-			t = (end_cells[i][1] - end_cells[i][0] + 1) * recv_buffer[i];
+			//t = (end_cells[i][1] - end_cells[i][0] + 1) * recv_buffer[i];
+			t = (end_cell[i] - start_cell[i] + 1) * recv_buffer[i];
 			if (t > max_old)
 				max_old = t;
 		}
@@ -3181,8 +3256,10 @@
 			/*          fprintf(stderr,"Stick\n"); */
 			for (i = 0; i < mpi_tasks; i++)
 			{
-				end_cells_new[i][0] = end_cells[i][0];
-				end_cells_new[i][1] = end_cells[i][1];
+				//end_cells_new[i][0] = end_cells[i][0];
+				start_cell_new[i] = start_cell[i];
+				//end_cells_new[i][1] = end_cells[i][1];
+				end_cell_new[i] = end_cell[i];
 			}
 		}
 		else
@@ -3191,12 +3268,15 @@
 			{
 				/*end_cells_new[i][1] = (end_cells_new[i][1] + end_cells[i][1])/2; */
 				/*end_cells_new[i][1] = end_cells_new[i][1]; */
-				icells =
-					(int) ((end_cells_new[i][1] -
-							end_cells[i][1]) * rebalance_fraction);
+				//icells = (int) ((end_cells_new[i][1] -
+				icells = (int) ((end_cell_new[i] -
+							//end_cells[i][1]) * rebalance_fraction);
+							end_cell[i]) * rebalance_fraction);
 				/*fprintf(stderr, "i %d, new %d, old %d, rebal_fraction %g, icells %d\n",i, end_cells_new[i][1], end_cells[i][1], rebalance_fraction, icells); */
-				end_cells_new[i][1] = end_cells[i][1] + icells;
-				end_cells_new[i + 1][0] = end_cells_new[i][1] + 1;
+				//end_cells_new[i][1] = end_cells[i][1] + icells;
+				end_cell_new[i] = end_cell[i] + icells;
+				//end_cells_new[i + 1][0] = end_cells_new[i][1] + 1;
+				start_cell_new[i + 1] = end_cell_new[i] + 1;
 			}
 		}
 #else
@@ -3213,7 +3293,9 @@
 	/*
 	 *   Broadcast new subcolumns
 	 */
-	MPI_Bcast(end_cells_new, 2 * mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	//MPI_Bcast(end_cells_new, 2 * mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	MPI_Bcast(&(start_cell_new[0]), mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	MPI_Bcast(&(end_cell_new[0]), mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
 	/*
 	 *   Redefine columns
 	 */
@@ -3231,11 +3313,13 @@
 			i = random_list[k];
 			iphrq = i;			/* iphrq is 1 to count_chem */
 			ihst = back[i].list[0];	/* ihst is 1 to nxyz */
-			while (k > end_cells[old][1])
+			//while (k > end_cells[old][1])
+			while (k > end_cell[old])
 			{
 				old++;
 			}
-			while (k > end_cells_new[nnew][1])
+			//while (k > end_cells_new[nnew][1])
+			while (k > end_cell_new[nnew])
 			{
 				nnew++;
 			}
@@ -3269,20 +3353,26 @@
 			}
 		}
 	}
-	mpi_first_cell = end_cells_new[mpi_myself][0];
-	mpi_last_cell = end_cells_new[mpi_myself][1];
+	//mpi_first_cell = end_cells_new[mpi_myself][0];
+	mpi_first_cell = start_cell_new[mpi_myself];
+	//mpi_last_cell = end_cells_new[mpi_myself][1];
+	mpi_last_cell = end_cell_new[mpi_myself];
 	for (i = 0; i < mpi_tasks; i++)
 	{
-		end_cells[i][0] = end_cells_new[i][0];
-		end_cells[i][1] = end_cells_new[i][1];
+		//end_cells[i][0] = end_cells_new[i][0];
+		start_cell[i] = start_cell_new[i];
+		//end_cells[i][1] = end_cells_new[i][1];
+		end_cell[i] = end_cell_new[i];
 		if (mpi_myself == 0)
 		{
 			/* fprintf(stderr, "Task %d: %d\t-\t%d\n", i, end_cells[i][0], end_cells[i][1]); */
 		}
 	}
+
+	// free buffer
+	free_check_null(recv_buffer);
 	return (OK);
 }
-
 /* ---------------------------------------------------------------------- */
 int
 mpi_rebalance_load_per_cell(double *times_per_cell, double *frac,
@@ -3305,9 +3395,16 @@
 		i,
 		j,
 		k;
+	//int
+		//end_cells_new[MPI_MAX_TASKS][2];
+	std::vector<int> start_cell_new;
+	std::vector<int> end_cell_new;
+	for (i = 0; i < mpi_tasks; i++)
+	{
+		start_cell_new.push_back(0);
+		end_cell_new.push_back(0);
+	}
 	int
-		end_cells_new[MPI_MAX_TASKS][2];
-	int
 		nnew,
 		old;
 	int
@@ -3324,7 +3421,8 @@
 	 */
 	if (mpi_myself == 0)
 	{
-		k = end_cells[0][1] - end_cells[0][0] + 1;
+		//k = end_cells[0][1] - end_cells[0][0] + 1;
+		k = end_cell[0] - start_cell[0] + 1;
 		for (i = 0; i < k; i++)
 		{
 			recv_cell_times[i] = times_per_cell[i];
@@ -3335,8 +3433,10 @@
 	 */
 	for (i = 1; i < mpi_tasks; i++)
 	{
-		j = end_cells[i][0];
-		k = end_cells[i][1] - end_cells[i][0] + 1;
+		//j = end_cells[i][0];
+		j = start_cell[i];
+		//k = end_cells[i][1] - end_cells[i][0] + 1;
+		k = end_cell[i] - start_cell[i] + 1;
 		if (mpi_myself == i)
 		{
 			MPI_Send(times_per_cell, k, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
@@ -3413,7 +3513,8 @@
 			double
 				tot = 0;
 			//std::cerr << i << "\tNormalizing cells: " << end_cells[i][0] << "  to  " << end_cells[i][1] << std::endl;
-			for (k = end_cells[i][0]; k <= end_cells[i][1]; k++)
+			//for (k = end_cells[i][0]; k <= end_cells[i][1]; k++)
+			for (k = start_cell[i]; k <= end_cell[i]; k++)
 			{
 				//std::cerr << k <<std::endl;
 				tot += recv_cell_times[k];
@@ -3465,11 +3566,13 @@
 		f_high = 1 + 0.5 / ((double) mpi_tasks);
 		f_low = 1;
 		j = 0;
-		end_cells_new[0][0] = 0;
+		//end_cells_new[0][0] = 0;
+		start_cell_new[0] = 0;
 		for (i = 0; i < mpi_tasks - 1; i++)
 		{
 			if (i > 0)
-				end_cells_new[i][0] = end_cells_new[i - 1][1] + 1;
+				//end_cells_new[i][0] = end_cells_new[i - 1][1] + 1;
+				start_cell_new[i] = end_cell_new[i - 1] + 1;
 			double
 				sum_work = 0;
 			double
@@ -3492,14 +3595,17 @@
 				}
 				else
 				{
-					if (j == end_cells_new[i][0])
+					//if (j == end_cells_new[i][0])
+					if (j == start_cell_new[i])
 					{
-						end_cells_new[i][1] = j;
+						//end_cells_new[i][1] = j;
+						end_cell_new[i] = j;
 						j++;
 					}
 					else
 					{
-						end_cells_new[i][1] = j - 1;
+						//end_cells_new[i][1] = j - 1;
+						end_cell_new[i] = j - 1;
 					}
 					next = FALSE;
 				}
@@ -3507,18 +3613,22 @@
 		}
 		assert(j < count_chem);
 		assert(mpi_tasks > 1);
-		end_cells_new[mpi_tasks - 1][0] = end_cells_new[mpi_tasks - 2][1] + 1;
-		end_cells_new[mpi_tasks - 1][1] = count_chem - 1;
+		//end_cells_new[mpi_tasks - 1][0] = end_cells_new[mpi_tasks - 2][1] + 1;
+		start_cell_new[mpi_tasks - 1] = end_cell_new[mpi_tasks - 2] + 1;
+		//end_cells_new[mpi_tasks - 1][1] = count_chem - 1;
+		end_cell_new[mpi_tasks - 1] = count_chem - 1;
 
 		/*
 		 *  Check that all cells are distributed
 		 */
-		if (end_cells_new[mpi_tasks - 1][1] != count_cells - 1)
+		//if (end_cells_new[mpi_tasks - 1][1] != count_cells - 1)
+		if (end_cell_new[mpi_tasks - 1] != count_cells - 1)
 		{
 			for (i = 0; i < mpi_tasks; i++)
 			{
 				output_msg(OUTPUT_STDERR, "%d: first %d\tlast %d\n", i,
-						   end_cells_new[i][0], end_cells_new[i][1]);
+						   //end_cells_new[i][0], end_cells_new[i][1]);
+						   start_cell_new[i], end_cell_new[i]);
 			}
 			error_msg("Failed to redistribute cells.", STOP);
 		}
@@ -3528,18 +3638,25 @@
 			int
 				icells;
 			icells =
-				(int) ((end_cells_new[i][1] -
-						end_cells[i][1]) * rebalance_fraction);
+				//(int) ((end_cells_new[i][1] -
+				(int) ((end_cell_new[i] -
+						//end_cells[i][1]) * rebalance_fraction);
+						end_cell[i]) * rebalance_fraction);
 			if (icells == 0)
-				icells = end_cells_new[i][1] - end_cells[i][1];
-			end_cells_new[i][1] = end_cells[i][1] + icells;
-			end_cells_new[i + 1][0] = end_cells_new[i][1] + 1;
+				//icells = end_cells_new[i][1] - end_cells[i][1];
+				icells = end_cell_new[i] - end_cell[i];
+			//end_cells_new[i][1] = end_cells[i][1] + icells;
+			end_cell_new[i] = end_cell[i] + icells;
+			//end_cells_new[i + 1][0] = end_cells_new[i][1] + 1;
+			start_cell_new[i + 1] = end_cell_new[i] + 1;
 		}
 	}							// mpi_myself = 0
 	/*
 	 *   Broadcast new subcolumns
 	 */
-	MPI_Bcast(end_cells_new, 2 * mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	//MPI_Bcast(end_cells_new, 2 * mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	MPI_Bcast(&(start_cell_new[0]), mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
+	MPI_Bcast(&(end_cell_new[0]), mpi_tasks, MPI_INT, 0, MPI_COMM_WORLD);
 	/*
 	 *   Redefine columns
 	 */
@@ -3557,11 +3674,13 @@
 			i = random_list[k];
 			iphrq = i;			/* iphrq is 1 to count_chem */
 			ihst = back[i].list[0];	/* ihst is 1 to nxyz */
-			while (k > end_cells[old][1])
+			//while (k > end_cells[old][1])
+			while (k > end_cell[old])
 			{
 				old++;
 			}
-			while (k > end_cells_new[nnew][1])
+			//while (k > end_cells_new[nnew][1])
+			while (k > end_cell_new[nnew])
 			{
 				nnew++;
 			}
@@ -3595,12 +3714,16 @@
 			}
 		}
 	}
-	mpi_first_cell = end_cells_new[mpi_myself][0];
-	mpi_last_cell = end_cells_new[mpi_myself][1];
+	//mpi_first_cell = end_cells_new[mpi_myself][0];
+	mpi_first_cell = start_cell_new[mpi_myself];
+	//mpi_last_cell = end_cells_new[mpi_myself][1];
+	mpi_last_cell = end_cell_new[mpi_myself];
 	for (i = 0; i < mpi_tasks; i++)
 	{
-		end_cells[i][0] = end_cells_new[i][0];
-		end_cells[i][1] = end_cells_new[i][1];
+		//end_cells[i][0] = end_cells_new[i][0];
+		start_cell[i] = start_cell_new[i];
+        //end_cells[i][1] = end_cells_new[i][1];
+		end_cell[i] = end_cell_new[i];
 		if (mpi_myself == 0)
 		{
 			/* fprintf(stderr, "Task %d: %d\t-\t%d\n", i, end_cells[i][0], end_cells[i][1]); */
@@ -3692,7 +3815,7 @@
 					 double *frac,
 					 int *printzone_chem, int *printzone_xyz,
 					 int *print_out, int *print_hdf, int *print_restart,
-					 double *pv, double *pv0)
+					 double *pv, double *pv0, int *przf_xyzt)
 /* ---------------------------------------------------------------------- */
 {
 	int
@@ -3709,8 +3832,7 @@
 	/*
 	 *  Send from print flags, frac, pv from root to nodes
 	 */
-	MPI_Status
-		mpi_status;
+	MPI_Status mpi_status;
 	MPI_Bcast(print_sel, 1, MPI_INT, 0, MPI_COMM_WORLD);
 	MPI_Bcast(time_hst, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
 	MPI_Bcast(time_step_hst, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
@@ -3718,6 +3840,7 @@
 	MPI_Bcast(print_out, 1, MPI_INT, 0, MPI_COMM_WORLD);
 	MPI_Bcast(print_hdf, 1, MPI_INT, 0, MPI_COMM_WORLD);
 	MPI_Bcast(print_restart, 1, MPI_INT, 0, MPI_COMM_WORLD);
+	MPI_Bcast(przf_xyzt, 1, MPI_INT, 0, MPI_COMM_WORLD);
 	if (mpi_myself == 0)
 	{
 		for (k = 0; k < count_chem; k++)
@@ -3732,8 +3855,10 @@
 	}
 	for (task_number = 1; task_number < mpi_tasks; task_number++)
 	{
-		j = end_cells[task_number][0];
-		k = end_cells[task_number][1] - end_cells[task_number][0] + 1;
+		//j = end_cells[task_number][0];
+		j = start_cell[task_number];
+		//k = end_cells[task_number][1] - end_cells[task_number][0] + 1;
+		k = end_cell[task_number] - start_cell[task_number] + 1;
 		if (mpi_myself == 0)
 		{
 			MPI_Send(&(random_frac[j]), k, MPI_DOUBLE, task_number, 0,
@@ -3813,8 +3938,10 @@
 					 &mpi_status);
 			int
 				d = 0;
-			for (k = end_cells[task_number][0];
-				 k <= end_cells[task_number][1]; k++)
+			//for (k = end_cells[task_number][0];
+			for (k = start_cell[task_number];
+				 //k <= end_cells[task_number][1]; k++)
+				 k <= end_cell[task_number]; k++)
 			{
 				for (i = 0; i < count_total; i++)
 				{
@@ -3834,8 +3961,10 @@
 		{
 			std::vector < double >
 				doubles;
-			for (k = end_cells[task_number][0];
-				 k <= end_cells[task_number][1]; k++)
+			//for (k = end_cells[task_number][0];
+			for (k = start_cell[task_number];
+				 //k <= end_cells[task_number][1]; k++)
+				 k <= end_cell[task_number]; k++)
 			{
 				i = random_list[k];	/* 1, count_chem */
 				j = back[i].list[0];
@@ -3860,7 +3989,8 @@
 	if (mpi_myself == 0)
 	{
 		/* unpack root solutions */
-		for (k = end_cells[0][0]; k <= end_cells[0][1]; k++)
+		//for (k = end_cells[0][0]; k <= end_cells[0][1]; k++)
+		for (k = start_cell[0]; k <= end_cell[0]; k++)
 		{
 			i = random_list[k];	/* 1, count_chem */
 			j = back[i].list[0];
@@ -3900,8 +4030,10 @@
 			mpi_buffer_position = 0;
 			std::vector < double >
 				doubles;
-			for (k = end_cells[task_number][0];
-				 k <= end_cells[task_number][1]; k++)
+			//for (k = end_cells[task_number][0];
+			for (k = start_cell[task_number];
+				 //k <= end_cells[task_number][1]; k++)
+				 k <= end_cell[task_number]; k++)
 			{
 				i = random_list[k];	/* i is 1 to count_chem */
 				cxxsolution_to_buffer(szBin.getSolution(i));
@@ -3932,7 +4064,8 @@
 					 MPI_COMM_WORLD, &mpi_status);
 			int
 				d = 0;
-			for (k = end_cells[rank][0]; k <= end_cells[rank][1]; k++)
+			//for (k = end_cells[rank][0]; k <= end_cells[rank][1]; k++)
+			for (k = start_cell[rank]; k <= end_cell[rank]; k++)
 			{
 				for (i = 0; i < count_total; i++)
 				{
@@ -3955,7 +4088,8 @@
 	if (mpi_myself == 0)
 	{
 		/* pack solutions from root process */
-		for (k = end_cells[0][0]; k <= end_cells[0][1]; k++)
+		//for (k = end_cells[0][0]; k <= end_cells[0][1]; k++)
+		for (k = start_cell[0]; k <= end_cell[0]; k++)
 		{
 			i = random_list[k];
 			cxxsolution_to_buffer(szBin.getSolution(i));
@@ -4213,6 +4347,7 @@
 	errors = setjmp(mark);
 	if (errors != 0)
 	{
+		HDF_Finalize();
 		clean_up();
 		exit(1);
 	}
@@ -4365,3 +4500,169 @@
 
 	return;
 }
+#ifdef USE_MPI
+void
+	WRITE_BC_RAW(int *solution_list, int * bc_solution_count, int * solution_number, char *prefix, int prefix_l)
+{
+	std::ofstream ofs;
+	std::ostringstream oss;
+
+
+	// solution_list is is Fortran m number
+	MPI_Bcast(solution_number, 1, MPI_INT, 0, MPI_COMM_WORLD);
+
+	if (*solution_number == 0) return;
+	MPI_Bcast(bc_solution_count, 1, MPI_INT, 0, MPI_COMM_WORLD);
+
+	int *my_solution_list;
+
+	if (mpi_myself == 0)
+	{
+		MPI_Bcast(solution_list, *bc_solution_count, MPI_INT, 0, MPI_COMM_WORLD);
+	}
+	else
+	{
+		my_solution_list = (int *) PHRQ_malloc((size_t) *bc_solution_count * sizeof(int));
+		if (my_solution_list == NULL) malloc_error();
+		MPI_Bcast(my_solution_list, *bc_solution_count, MPI_INT, 0, MPI_COMM_WORLD);
+	}
+
+	if (mpi_myself == 0) 
+	{
+		std::string fn(prefix, prefix_l);
+		fn = trim_right(fn);
+		ofs.open(fn.c_str(), std::ios_base::app);
+		if (!ofs.is_open())
+		{
+			error_msg(sformatf("Could not open file. %s", fn.c_str()), STOP);
+		}
+	}
+	std::set<int> my_solns;
+	int	first_cell = mpi_first_cell;
+	int last_cell = mpi_last_cell;
+
+	// first and last cell in random_list, count_chem in length
+	for (int k = first_cell; k <= last_cell; k++)
+	{
+		my_solns.insert(random_list[k]);
+	}
+
+	for (int i = 0; i < *bc_solution_count; i++)
+	{
+		int raw_number = *solution_number + i;
+		int n_fort;
+		if (mpi_myself == 0)
+		{
+			n_fort = solution_list[i];
+		}
+		else
+		{
+			n_fort = my_solution_list[i];
+		}
+
+		int n_chem = forward1[n_fort - 1];
+		if (my_solns.find(n_chem) != my_solns.end())
+		{
+			if (szBin.getSolution(n_chem) == NULL) 
+			{
+				cerr << mpi_myself << "Could not find n_chem " << n_chem << std::endl;
+				continue;
+			}
+			if (mpi_myself == 0)
+			{
+
+				ofs << "# Fortran cell " << n_fort << ". Time " << rate_sim_time_end << "\n";
+				szBin.getSolution(n_chem)->dump_raw(ofs, raw_number, 0);
+			}
+			else
+			{
+				oss << "# Fortran cell " << n_fort << ". Time " << rate_sim_time_end << "\n";
+				szBin.getSolution(n_chem)->dump_raw(oss, raw_number, 0);
+			}
+		}
+	}
+
+	// Retrieve from nonroot processes
+
+	char *mpi_buffer;
+	int max_buffer_length = 1028;
+	mpi_buffer = (char *) PHRQ_malloc((size_t) (max_buffer_length + 10) * sizeof (char));
+	for (int task_number = 1; task_number < mpi_tasks; task_number++)
+	{
+		int buffer_length = 0;
+		MPI_Status mpi_status;
+		if (mpi_myself == 0)
+		{
+			MPI_Recv(&buffer_length, 1, MPI_INT, task_number, 0, MPI_COMM_WORLD,
+				&mpi_status);
+			if (buffer_length > 0)
+			{
+				if (max_buffer_length <= buffer_length)
+				{
+					max_buffer_length = buffer_length;
+					mpi_buffer = (char *) PHRQ_realloc(mpi_buffer, (size_t) max_buffer_length + 10);
+				}
+
+				MPI_Recv(mpi_buffer, buffer_length, MPI_CHAR, task_number, 0,
+					MPI_COMM_WORLD, &mpi_status);
+				mpi_buffer[buffer_length] = '\0';
+				ofs << mpi_buffer; // << "\n";
+			}
+		}
+		if (mpi_myself == task_number)
+		{
+			buffer_length = (int) oss.str().size();
+			MPI_Send(&buffer_length, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
+			if (buffer_length > 0)
+			{
+				MPI_Send((void *) oss.str().c_str(), buffer_length, MPI_CHAR, 0, 0,
+					MPI_COMM_WORLD);
+			}
+		}
+	}
+	MPI_Barrier(MPI_COMM_WORLD);
+
+	if (mpi_myself == 0)
+	{
+		//*solution_number = raw_number;
+		ofs << "# Done with zone for time step." << std::endl;
+		ofs.close();
+	}
+	free_check_null(mpi_buffer);
+	return;
+}
+#else
+void
+	WRITE_BC_RAW(int *solution_list, int * bc_solution_count, int * solution_number, char *prefix, int prefix_l)
+{
+	if (*solution_number == 0) return;
+	std::string fn(prefix, prefix_l);
+	fn = trim_right(fn);
+	std::ofstream ofs;
+	ofs.open(fn.c_str(), std::ios_base::app);
+	if (!ofs.is_open())
+	{
+		error_msg(sformatf("Could not open file. %s", fn.c_str()), STOP);
+	}
+
+	int raw_number = *solution_number;
+	for (int i = 0; i < *bc_solution_count; i++)
+	{
+		int n_fort = solution_list[i];
+		int n_chem = forward1[n_fort - 1];
+		if (n_chem >= 0)
+		{
+			ofs << "# Fortran cell " << n_fort << ". Time " << rate_sim_time_end << "\n";
+			szBin.getSolution(n_chem)->dump_raw(ofs, raw_number++, 0);
+		}
+		else
+		{
+			assert(false);
+		}
+	}
+	//*solution_number = raw_number;
+	ofs << "# Done with zone for time step." << std::endl;
+	ofs.close();
+	return;
+}
+#endif
Index: closef.F90
===================================================================
--- closef.F90	(revision 5000)
+++ closef.F90	(revision 6719)
@@ -166,7 +166,7 @@
   ! fuzf_heads opened and closed in zone_flow_write_heads 
   ! for multiple files 
   !st(fuzf_heads) = 'delete'    
-  !IF(ntprzf_heads > 0) st(fuzf_heads) = 'keep  '  
+  !IF(ntprzf_xyzt > 0) st(fuzf_heads) = 'keep  '  
 !!$  st(fut) = 'delete'  
 !!$#if defined(MERGE_FILES)
 !!$  CALL update_status(st)
@@ -270,17 +270,19 @@
         do izn = 1, num_flo_zones
         
           ! deallocate list of cell top and bottom numbers if needed
-          IF((fresur .AND. (nfbc > 0 .OR. nrbc > 0)) .or. zone_write_heads(izn)) THEN
-            DEALLOCATE (zone_col(izn)%i_no,  &
-                zone_col(izn)%j_no,  &
-                zone_col(izn)%kmin_no,  &
-                zone_col(izn)%kmax_no,  &
-                stat = da_err)
-            IF (da_err /= 0) THEN
-              PRINT *, "Array deallocation failed: closef: number 2.0"
-              STOP
-            ENDIF       
-          ENDIF 
+          IF (zone_col(izn)%num_xycol > 0) THEN
+              IF((fresur .AND. (nfbc > 0 .OR. nrbc > 0)) .or. zone_write_heads(izn)) THEN
+                DEALLOCATE (zone_col(izn)%i_no,  &
+                    zone_col(izn)%j_no,  &
+                    zone_col(izn)%kmin_no,  &
+                    zone_col(izn)%kmax_no,  &
+                    stat = da_err)
+                IF (da_err /= 0) THEN
+                  PRINT *, "Array deallocation failed: closef: number 2.0"
+                  STOP
+                ENDIF       
+              ENDIF 
+          ENDIF
           
           ! flow zone face parameters
           IF(zone_ib(izn)%num_int_faces > 0) THEN
@@ -381,7 +383,7 @@
           END IF  ! nwel       
         enddo  ! num_flo_zones
               
-        DEALLOCATE (zone_title, &
+        DEALLOCATE (zone_title, zone_number, &
           zone_ib, lnk_bc2zon, &
           seg_well, &
           zone_filename_heads, &
Index: hdf.c
===================================================================
--- hdf.c	(revision 5000)
+++ hdf.c	(revision 6719)
@@ -3,6 +3,7 @@
 */
 
 #ifdef USE_MPI
+#include <vector>
 //MPICH seems to require mpi.h to be first
 #include <mpi.h>
 #endif
@@ -18,7 +19,7 @@
 static char const svnid[] = "$Id$";
 
 #ifdef USE_MPI
-#define MPI_MAX_TASKS 50		/* from hst.c */
+//#define MPI_MAX_TASKS 50		/* from hst.c */
 static char const DEFINE_USE_MPI[] = "#define USE_MPI 1";
 #else
 static char const DEFINE_USE_MPI[] = "#define USE_MPI 0";
@@ -49,6 +50,7 @@
 static int hdf_callback(const int action, const int type, const char *name,
 						const int stop, void *cookie, const char *format,
 						va_list args);
+static void hdf_finalize_headings(void);
 
 
 /*
@@ -90,6 +92,9 @@
 	int vector_name_count;
 	char **vector_names;
 	size_t vector_name_max_len;
+	size_t intermediate_idx;
+	std::string hdf_prefix;
+	std::string hdf_file_name;
 } root;
 
 /*
@@ -195,6 +200,8 @@
 		root.vector_names = NULL;
 		root.vector_name_count = 0;
 		root.vector_name_max_len = 0;
+
+		root.intermediate_idx = 0;
 	}
 
 	/* init proc */
@@ -229,112 +236,15 @@
 
 	if (mpi_myself == 0)
 	{
-		hid_t fls_type;
 		herr_t status;
 
 		assert(root.current_file_dspace_id == -1);	/* shouldn't be open */
 		assert(root.current_file_dset_id == -1);	/* shouldn't be open */
 
-		/* create fixed length string type for /Scalar /TimeSteps and /Vectors */
-		fls_type = H5Tcopy(H5T_C_S1);
-		if (fls_type <= 0)
-		{
-			assert(0);
-			sprintf(error_string, "HDF ERROR: Unable to copy H5T_C_S1.\n");
-			error_msg(error_string, STOP);
-		}
-		status = H5Tset_strpad(fls_type, H5T_STR_NULLTERM);
-		if (status < 0)
-		{
-			assert(0);
-			sprintf(error_string,
-					"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
-					(int) root.scalar_name_max_len);
-			error_msg(error_string, STOP);
-		}
+		hdf_finalize_headings();
 
-
 		if (root.scalar_name_count > 0)
 		{
-			hsize_t dims[1];
-			hid_t dspace;
-			hid_t dset;
-			char *scalar_names;
-
-			/*
-			 * write scalar names to file
-			 */
-
-			status = H5Tset_size(fls_type, root.scalar_name_max_len);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
-						(int) root.scalar_name_max_len);
-				error_msg(error_string, STOP);
-			}
-
-			assert(root.scalar_names != NULL);
-
-			/* create the /Scalars dataspace */
-			dims[0] = root.scalar_name_count;
-			dspace = H5Screate_simple(1, dims, NULL);
-			if (dspace <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
-						szScalars);
-				error_msg(error_string, STOP);
-			}
-
-			/* create the /Scalars dataset */
-			dset =
-				H5Dcreate(root.hdf_file_id, szScalars, fls_type, dspace,
-						  H5P_DEFAULT);
-			if (dset <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset.\n",
-						szScalars);
-				error_msg(error_string, STOP);
-			}
-
-			/* copy variable length scalar names to fixed length scalar names */
-			scalar_names =
-				(char *) PHRQ_calloc(root.scalar_name_max_len *
-									 root.scalar_name_count, sizeof(char));
-			/* java req'd */
-			for (i = 0; i < root.scalar_name_count; ++i)
-			{
-				strcpy(scalar_names + i * root.scalar_name_max_len,
-					   root.scalar_names[i]);
-			}
-
-			/* write the /Scalars dataset */
-			status =
-				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-						 scalar_names);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to write the /%s dataset.\n",
-						szScalars);
-				error_msg(error_string, STOP);
-			}
-
-			PHRQ_free(scalar_names);
-
-			status = H5Sclose(dspace);
-			assert(status >= 0);
-
-			status = H5Dclose(dset);
-			assert(status >= 0);
-
-
 			/* free space */
 			for (i = 0; i < root.scalar_name_count; ++i)
 			{
@@ -348,85 +258,6 @@
 
 		if (root.vector_name_count > 0)
 		{
-			hsize_t dims[1];
-			hid_t dspace;
-			hid_t dset;
-			char *vector_names;
-
-			/*
-			 * write vector names to file
-			 */
-
-			assert(root.vector_name_count == 1);	/* Has a new vector been added? */
-			assert(root.vector_names != NULL);
-
-			status = H5Tset_size(fls_type, root.vector_name_max_len);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
-						(int) root.scalar_name_max_len);
-				error_msg(error_string, STOP);
-			}
-
-
-			/* create the /Vectors dataspace */
-			dims[0] = root.vector_name_count;
-			dspace = H5Screate_simple(1, dims, NULL);
-			if (dspace <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
-						szVectors);
-				error_msg(error_string, STOP);
-			}
-
-			/* create the /Vectors dataset */
-			dset =
-				H5Dcreate(root.hdf_file_id, szVectors, fls_type, dspace,
-						  H5P_DEFAULT);
-			if (dset <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset.\n",
-						szVectors);
-				error_msg(error_string, STOP);
-			}
-
-			/* copy variable length vectors to fixed length strings */
-			vector_names =
-				(char *) PHRQ_calloc(root.vector_name_max_len *
-									 root.vector_name_count, sizeof(char));
-			for (i = 0; i < root.vector_name_count; ++i)
-			{
-				strcpy(vector_names + i * root.vector_name_max_len,
-					   root.vector_names[i]);
-			}
-
-			/* write the /Vectors dataset */
-			status =
-				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-						 vector_names);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to write the /%s dataset.\n",
-						szVectors);
-				error_msg(error_string, STOP);
-			}
-
-			PHRQ_free(vector_names);
-
-			status = H5Sclose(dspace);
-			assert(status >= 0);
-
-			status = H5Dclose(dset);
-			assert(status >= 0);
-
 			/* free space */
 			for (i = 0; i < root.vector_name_count; ++i)
 			{
@@ -440,83 +271,6 @@
 
 		if (root.time_step_count > 0)
 		{
-			hsize_t dims[1];
-			hid_t dspace;
-			hid_t dset;
-			char *time_steps;
-
-			/*
-			 * write time step names to file
-			 */
-
-			status = H5Tset_size(fls_type, root.time_step_max_len);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
-						(int) root.time_step_max_len);
-				error_msg(error_string, STOP);
-			}
-
-			assert(root.time_steps != NULL);
-
-			/* create the /TimeSteps (szTimeSteps) dataspace */
-			dims[0] = root.time_step_count;
-			dspace = H5Screate_simple(1, dims, NULL);
-			if (dspace <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
-						szTimeSteps);
-				error_msg(error_string, STOP);
-			}
-
-			/* create the /TimeSteps (szTimeSteps) dataset */
-			dset =
-				H5Dcreate(root.hdf_file_id, szTimeSteps, fls_type, dspace,
-						  H5P_DEFAULT);
-			if (dset <= 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to create the /%s dataset.\n",
-						szTimeSteps);
-				error_msg(error_string, STOP);
-			}
-
-			/* copy variable length time steps to fixed length strings */
-			time_steps =
-				(char *) PHRQ_calloc(root.time_step_max_len *
-									 root.time_step_count, sizeof(char));
-			for (i = 0; i < root.time_step_count; ++i)
-			{
-				strcpy(time_steps + i * root.time_step_max_len,
-					   root.time_steps[i]);
-			}
-
-			/* write the /TimeSteps (szTimeSteps) dataset */
-			status =
-				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-						 time_steps);
-			if (status < 0)
-			{
-				assert(0);
-				sprintf(error_string,
-						"HDF ERROR: Unable to write the /%s dataset.\n",
-						szTimeSteps);
-				error_msg(error_string, STOP);
-			}
-
-			PHRQ_free(time_steps);
-
-			status = H5Sclose(dspace);
-			assert(status >= 0);
-
-			status = H5Dclose(dset);
-			assert(status >= 0);
-
 			/* free space */
 			for (i = 0; i < root.time_step_count; ++i)
 			{
@@ -528,10 +282,6 @@
 			root.time_step_max_len = 0;
 		}
 
-		/* close the fixed lenght string type */
-		status = H5Tclose(fls_type);
-		assert(status >= 0);
-
 		/* free mem */
 #ifdef USE_MPI
 		assert(root.recv_array != NULL || root.recv_array_count == 0);
@@ -573,7 +323,6 @@
 	proc.array = NULL;
 }
 
-
 /*-------------------------------------------------------------------------
  * Function          open_hdf_file
  *
@@ -611,6 +360,8 @@
 
 	if (mpi_myself == 0)
 	{
+		root.hdf_prefix    = hdf_prefix;
+		root.hdf_file_name = hdf_file_name;
 		if (file_exists(hdf_file_name))
 		{
 			sprintf(hdf_backup_name, "%s%s~", hdf_prefix, szHDF5Ext);
@@ -1220,7 +971,9 @@
 HDFBeginCTimeStep(void)
 {
 #ifdef USE_MPI
-	extern int end_cells[MPI_MAX_TASKS][2];
+	//extern int end_cells[MPI_MAX_TASKS][2];
+	extern std::vector<int> start_cell;
+	extern std::vector<int> end_cell;
 	extern int *random_list;
 	extern int mpi_myself;
 
@@ -1238,8 +991,10 @@
 	assert(count_back_list == 1 || count_back_list == 2
 		   || count_back_list == 4);
 	/* determine how many cells we're going to be doing */
-	ptr_begin = &(random_list[end_cells[mpi_myself][0]]);
-	ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+	//ptr_begin = &(random_list[end_cells[mpi_myself][0]]);
+	ptr_begin = &(random_list[start_cell[mpi_myself]]);
+	//ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+	ptr_end = &(random_list[end_cell[mpi_myself]]);
 	proc.cell_count = (int) (ptr_end - ptr_begin + 1);
 #else
 	proc.cell_count = count_chem;
@@ -1301,7 +1056,9 @@
 #ifndef NDEBUG
 #ifdef USE_MPI
 	{
-		extern int end_cells[MPI_MAX_TASKS][2];
+		//extern int end_cells[MPI_MAX_TASKS][2];
+		extern std::vector<int> start_cell;
+		extern std::vector<int> end_cell;
 		extern int *random_list;
 		extern int mpi_myself;
 		extern int int_compare(const void *, const void *);
@@ -1310,8 +1067,10 @@
 		int *ptr_end;
 
 		/* verify cell_count */
-		ptr_begin = &(random_list[end_cells[mpi_myself][0]]);
-		ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+		//ptr_begin = &(random_list[end_cells[mpi_myself][0]]);
+		ptr_begin = &(random_list[start_cell[mpi_myself]]);
+		//ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+		ptr_end = &(random_list[end_cell[mpi_myself]]);
 		assert(proc.cell_count == ptr_end - ptr_begin + 1);
 
 		/* verify n (natural cell index) */
@@ -1319,7 +1078,8 @@
 			(int *) PHRQ_malloc((size_t) (proc.cell_count) * sizeof(int));
 		if (sort_random_list == NULL)
 			malloc_error();
-		memcpy(sort_random_list, &random_list[end_cells[mpi_myself][0]],
+		//memcpy(sort_random_list, &random_list[end_cells[mpi_myself][0]],
+		memcpy(sort_random_list, &random_list[start_cell[mpi_myself]],
 			   sizeof(int) * proc.cell_count);
 		qsort(sort_random_list, (size_t) (proc.cell_count), sizeof(int),
 			  int_compare);
@@ -1438,7 +1198,9 @@
 					hid_t dset_id, double *array)
 {
 #ifdef USE_MPI
-	extern int end_cells[MPI_MAX_TASKS][2];
+	//extern int end_cells[MPI_MAX_TASKS][2];
+	extern std::vector<int> start_cell;
+	extern std::vector<int> end_cell;
 	extern int *random_list;
 	extern int int_compare(const void *, const void *);
 	int *sort_random_list;
@@ -1513,15 +1275,18 @@
 #else
 	/* MPI */
 	assert(cell_count ==
-		   &(random_list[end_cells[rank][1]]) -
-		   &(random_list[end_cells[rank][0]]) + 1);
+		  // &(random_list[end_cells[rank][1]]) -
+		  &(random_list[end_cell[rank]]) -
+		  //&(random_list[end_cells[rank][0]]) + 1);
+		  &(random_list[start_cell[rank]]) + 1);
 
 	/* sort random list for this proc (to be used for element selection */
 	sort_random_list =
 		(int *) PHRQ_malloc((size_t) (cell_count) * sizeof(int));
 	if (sort_random_list == NULL)
 		malloc_error();
-	memcpy(sort_random_list, &random_list[end_cells[rank][0]],
+	//memcpy(sort_random_list, &random_list[end_cells[rank][0]],
+	memcpy(sort_random_list, &random_list[start_cell[rank]],
 		   sizeof(int) * cell_count);
 	qsort(sort_random_list, (size_t) (cell_count), sizeof(int), int_compare);
 
@@ -1811,6 +1576,7 @@
 
 		assert(proc.array != NULL);	/* Has HDFBeginCTimeStep been called?
 									   Is HDF5_CREATE defined in Fortran? */
+		if (proc.array == NULL) return;
 
 		/* validate scalar_index */
 		assert(proc.scalar_index >= 0);
@@ -1908,17 +1674,20 @@
 	/* copy the fortran scalar array into the active scalar array (f_array) */
 	assert(root.f_array != NULL);
 	assert(root.active_count > 0);
-	for (i = 0; i < root.active_count; ++i)
+	if (root.active && root.f_array && frac)
 	{
-		assert(root.active[i] >= 0 && root.active[i] < root.nxyz);
-		if (frac[root.active[i]] <= 0.0001)
+		for (i = 0; i < root.active_count; ++i)
 		{
-			root.f_array[i] = INACTIVE_CELL_VALUE;
+			assert(root.active[i] >= 0 && root.active[i] < root.nxyz);
+			if (frac[root.active[i]] <= 0.0001)
+			{
+				root.f_array[i] = INACTIVE_CELL_VALUE;
+			}
+			else
+			{
+				root.f_array[i] = array[root.active[i]] * (*cnv);
+			}
 		}
-		else
-		{
-			root.f_array[i] = array[root.active[i]] * (*cnv);
-		}
 	}
 
 	/* create the memory dataspace */
@@ -2136,3 +1905,362 @@
 	}
 	return (OK);
 }
+
+void
+HDF_INTERMEDIATE(void)
+{
+#ifdef USE_MPI
+	extern int mpi_myself;
+#else
+	const int mpi_myself = 0;
+#endif
+
+	if (mpi_myself == 0)
+	{
+		herr_t status;
+
+		// close the file
+		assert(root.hdf_file_id > 0);
+		status = H5Fclose(root.hdf_file_id);
+		assert(status >= 0);
+
+		// create intermediate filename
+		char int_fn[MAX_PATH];
+		sprintf(int_fn, "%s.intermediate%s", root.hdf_prefix.c_str(), szHDF5Ext);
+		
+		// copy to the intermediate file
+		char command[3*MAX_PATH];
+#if WIN32
+		sprintf(command, "copy %s %s", root.hdf_file_name.c_str(), int_fn);
+#else
+		sprintf(command, "cp %s %s", root.hdf_file_name.c_str(), int_fn);
+#endif
+		system(command);
+
+		// open intermediate file for finalization
+		root.hdf_file_id = H5Fopen(int_fn, H5F_ACC_RDWR , H5P_DEFAULT);
+		if (root.hdf_file_id <= 0)
+		{
+			sprintf(error_string, "Unable to open HDF file:%s\n", int_fn);
+			error_msg(error_string, STOP);
+		}
+
+		// finalize intermediate
+		hdf_finalize_headings();
+
+		// close the file
+		assert(root.hdf_file_id > 0);
+		status = H5Fclose(root.hdf_file_id);
+		assert(status >= 0);
+	}
+
+	// reopen hdf file
+	root.hdf_file_id = H5Fopen(root.hdf_file_name.c_str(), H5F_ACC_RDWR , H5P_DEFAULT);
+	if (root.hdf_file_id <= 0)
+	{
+		sprintf(error_string, "Unable to open HDF file:%s\n", root.hdf_file_name.c_str());
+		error_msg(error_string, STOP);
+	}
+}
+
+
+/*-------------------------------------------------------------------------
+ * Function          hdf_finalize_headings
+ *
+ * Preconditions:    TODO:
+ *
+ * Postconditions:   TODO:
+ *-------------------------------------------------------------------------
+ */
+static void
+hdf_finalize_headings(void)
+{
+	int i;
+
+#ifdef USE_MPI
+	extern int mpi_myself;
+#else
+	const int mpi_myself = 0;
+#endif
+
+	if (mpi_myself == 0)
+	{
+		herr_t status;
+		hid_t fls_type;
+
+		assert(root.current_file_dspace_id == -1);	// shouldn't be open
+		assert(root.current_file_dset_id == -1);	// shouldn't be open
+
+		// create fixed length string type for /Scalar /TimeSteps and /Vectors
+		fls_type = H5Tcopy(H5T_C_S1);
+		if (fls_type <= 0)
+		{
+			assert(0);
+			sprintf(error_string, "HDF ERROR: Unable to copy H5T_C_S1.\n");
+			error_msg(error_string, STOP);
+		}
+		status = H5Tset_strpad(fls_type, H5T_STR_NULLTERM);
+		if (status < 0)
+		{
+			assert(0);
+			sprintf(error_string,
+					"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
+					(int) root.scalar_name_max_len);
+			error_msg(error_string, STOP);
+		}
+
+
+		if (root.scalar_name_count > 0)
+		{
+			hsize_t dims[1];
+			hid_t dspace;
+			hid_t dset;
+			char *scalar_names;
+
+			// write scalar names to file
+
+			status = H5Tset_size(fls_type, root.scalar_name_max_len);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
+						(int) root.scalar_name_max_len);
+				error_msg(error_string, STOP);
+			}
+
+			assert(root.scalar_names != NULL);
+
+			// create the /Scalars dataspace
+			dims[0] = root.scalar_name_count;
+			dspace = H5Screate_simple(1, dims, NULL);
+			if (dspace <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
+						szScalars);
+				error_msg(error_string, STOP);
+			}
+
+			// create the /Scalars dataset
+			dset =
+				H5Dcreate(root.hdf_file_id, szScalars, fls_type, dspace,
+						  H5P_DEFAULT);
+			if (dset <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset.\n",
+						szScalars);
+				error_msg(error_string, STOP);
+			}
+
+			// copy variable length scalar names to fixed length scalar names
+			scalar_names =
+				(char *) PHRQ_calloc(root.scalar_name_max_len *
+									 root.scalar_name_count, sizeof(char));
+			// java req'd
+			for (i = 0; i < root.scalar_name_count; ++i)
+			{
+				strcpy(scalar_names + i * root.scalar_name_max_len,
+					   root.scalar_names[i]);
+			}
+
+			// write the /Scalars dataset
+			status =
+				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
+						 scalar_names);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to write the /%s dataset.\n",
+						szScalars);
+				error_msg(error_string, STOP);
+			}
+
+			PHRQ_free(scalar_names);
+
+			status = H5Sclose(dspace);
+			assert(status >= 0);
+
+			status = H5Dclose(dset);
+			assert(status >= 0);
+		}
+
+		if (root.vector_name_count > 0)
+		{
+			hsize_t dims[1];
+			hid_t dspace;
+			hid_t dset;
+			char *vector_names;
+
+			// write vector names to file
+
+			assert(root.vector_name_count == 1);	// Has a new vector been added?
+			assert(root.vector_names != NULL);
+
+			status = H5Tset_size(fls_type, root.vector_name_max_len);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
+						(int) root.scalar_name_max_len);
+				error_msg(error_string, STOP);
+			}
+
+
+			// create the /Vectors dataspace
+			dims[0] = root.vector_name_count;
+			dspace = H5Screate_simple(1, dims, NULL);
+			if (dspace <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
+						szVectors);
+				error_msg(error_string, STOP);
+			}
+
+			// create the /Vectors dataset
+			dset =
+				H5Dcreate(root.hdf_file_id, szVectors, fls_type, dspace,
+						  H5P_DEFAULT);
+			if (dset <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset.\n",
+						szVectors);
+				error_msg(error_string, STOP);
+			}
+
+			// copy variable length vectors to fixed length strings
+			vector_names =
+				(char *) PHRQ_calloc(root.vector_name_max_len *
+									 root.vector_name_count, sizeof(char));
+			for (i = 0; i < root.vector_name_count; ++i)
+			{
+				strcpy(vector_names + i * root.vector_name_max_len,
+					   root.vector_names[i]);
+			}
+
+			// write the /Vectors dataset
+			status =
+				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
+						 vector_names);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to write the /%s dataset.\n",
+						szVectors);
+				error_msg(error_string, STOP);
+			}
+
+			PHRQ_free(vector_names);
+
+			status = H5Sclose(dspace);
+			assert(status >= 0);
+
+			status = H5Dclose(dset);
+			assert(status >= 0);
+		}
+
+		if (root.time_step_count > 0)
+		{
+			hsize_t dims[1];
+			hid_t dspace;
+			hid_t dset;
+			char *time_steps;
+
+			// write time step names to file
+
+			status = H5Tset_size(fls_type, root.time_step_max_len);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to set size of fixed length string type(size=%d).\n",
+						(int) root.time_step_max_len);
+				error_msg(error_string, STOP);
+			}
+
+			assert(root.time_steps != NULL);
+
+			// create the /TimeSteps (szTimeSteps) dataspace
+			dims[0] = root.time_step_count;
+			dspace = H5Screate_simple(1, dims, NULL);
+			if (dspace <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset dataspace.\n",
+						szTimeSteps);
+				error_msg(error_string, STOP);
+			}
+
+			// create the /TimeSteps (szTimeSteps) dataset
+			dset =
+				H5Dcreate(root.hdf_file_id, szTimeSteps, fls_type, dspace,
+						  H5P_DEFAULT);
+			if (dset <= 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to create the /%s dataset.\n",
+						szTimeSteps);
+				error_msg(error_string, STOP);
+			}
+
+			// copy variable length time steps to fixed length strings
+			time_steps =
+				(char *) PHRQ_calloc(root.time_step_max_len *
+									 root.time_step_count, sizeof(char));
+			for (i = 0; i < root.time_step_count; ++i)
+			{
+				strcpy(time_steps + i * root.time_step_max_len,
+					   root.time_steps[i]);
+			}
+
+			// write the /TimeSteps (szTimeSteps) dataset
+			status =
+				H5Dwrite(dset, fls_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
+						 time_steps);
+			if (status < 0)
+			{
+				assert(0);
+				sprintf(error_string,
+						"HDF ERROR: Unable to write the /%s dataset.\n",
+						szTimeSteps);
+				error_msg(error_string, STOP);
+			}
+
+			PHRQ_free(time_steps);
+
+			status = H5Sclose(dspace);
+			assert(status >= 0);
+
+			status = H5Dclose(dset);
+			assert(status >= 0);
+		}
+
+		// close the fixed lenght string type
+		status = H5Tclose(fls_type);
+		assert(status >= 0);
+
+		// close the file
+		assert(root.hdf_file_id > 0);
+		status = H5Fclose(root.hdf_file_id);
+		assert(status >= 0);
+	}
+
+	root.hdf_file_id = H5Fopen(root.hdf_file_name.c_str(), H5F_ACC_RDWR , H5P_DEFAULT);
+	if (root.hdf_file_id <= 0)
+	{
+		sprintf(error_string, "Unable to open HDF file:%s\n", root.hdf_file_name.c_str());
+		error_msg(error_string, STOP);
+	}
+}
Index: terminate_phast.F90
===================================================================
--- terminate_phast.F90	(revision 5000)
+++ terminate_phast.F90	(revision 6719)
@@ -33,7 +33,7 @@
      stop_msg = 1
      CALL equilibrate(c,nxyz,idummy,x_node,y_node,z_node,time,deltim,prslmi,cnvtmi,  &
        frac, iprint_chem, iprint_xyz, idummy, stop_msg, &
-       idummy, dummy, idummy, dummy, dummy, idummy, dummy)
+       idummy, dummy, idummy, dummy, dummy, idummy, dummy, dummy)
      ! ... Print initial condition head distribution to file
      IF(prtichead) THEN
         ! ... Write to file 'FUICH' for initial condition steady-state head or
Index: zone_flow.f90
===================================================================
--- zone_flow.f90	(revision 5000)
+++ zone_flow.f90	(revision 6719)
@@ -641,16 +641,19 @@
   REAL(KIND=kdp) :: current_time = 0
   INTEGER :: counter = 1
   SAVE current_time, counter
- 
+  CHARACTER * 130 file_name_base, file_name
+
   current_time = cnvtmi*time
   do izn = 1, num_flo_zones
     if (zone_write_heads(izn)) then
+        file_name_base = zone_filename_heads(izn)
+        file_name = trim(file_name_base) // ".heads.xyzt"
         if (counter == 1) then
             ! delete file on first write
-            OPEN(fuzf_heads,FILE=zone_filename_heads(izn),IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
+            OPEN(fuzf_heads,FILE=file_name,IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
             write(fuzf_heads,"(a20,a20,a20,a13,a6,a1,a20)") "X","Y","Z","T(",TRIM(unittm),")","Head"
         else
-            OPEN(fuzf_heads,FILE=zone_filename_heads(izn),IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
+            OPEN(fuzf_heads,FILE=file_name,IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
         endif 
         do i = 1, zone_col(izn)%num_xycol
             ii = zone_col(izn)%i_no(i)
@@ -670,6 +673,100 @@
   counter = counter + 1
 
 END SUBROUTINE zone_flow_write_heads
+
+
+SUBROUTINE zone_flow_write_chem(mpi_tasks, mpi_myself, force_print)
+  ! ... Writes solution_raw for zones for zones 
+  USE machine_constants, ONLY: kdp
+  USE f_units
+  USE mcb2
+  USE mcc
+  USE mcch
+  USE mcg
+  USE mcn, ONLY: x, y, z
+  USE mcp
+  USE mcv
+  USE mg2, ONLY: hdprnt
+!!$  USE phys_const
+  IMPLICIT NONE
+  !LOGICAL ex
+  INTEGER, INTENT(IN) :: mpi_myself, mpi_tasks
+  LOGICAL, INTENT(IN) :: force_print
+  INTEGER ios
+  INTEGER i, ii, jj, kk, m, izn
+  REAL(KIND=kdp) :: current_time = 0
+  INTEGER :: counter = 1
+  INTEGER :: solution_number, solution_number_start, bc_soln_count
+  SAVE current_time, counter, solution_number_start
+  CHARACTER * 130 file_name_base, file_name
+  INTEGER solution_list(nxyz), pos
+ 
+  IF (.not. solute) RETURN
+  IF(.not. przf_xyzt .and. .not. force_print) RETURN
+
+  current_time = cnvtmi*time
+  if (counter == 1) then
+    solution_number_start = 10000000
+  endif
+  bc_soln_count = 1
+  if (mpi_myself == 0) then 
+     do izn = 1, num_flo_zones
+        if (zone_write_heads(izn)) then
+           file_name_base = zone_filename_heads(izn)
+           if (counter == 1) then
+              ! delete file on first write
+              ! xyzt file
+              file_name = trim(file_name_base) // ".soln.xyzt"
+              OPEN(fuzf_chem_xyzt,FILE=file_name,IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
+              write(fuzf_chem_xyzt,"(a20,a20,a20,a13,a6,a1,a20)") "X","Y","Z","T(",TRIM(unittm),")","Soln_no"
+              ! chem raw file
+              file_name = trim(file_name_base) // ".soln.bc"
+              OPEN(fuzf_chem_raw,FILE=file_name,IOSTAT=ios,ACTION='WRITE',STATUS='REPLACE')
+              CLOSE(fuzf_chem_raw)
+           else
+              ! xyzt file
+              file_name = trim(file_name_base) // ".soln.xyzt"
+              OPEN(fuzf_chem_xyzt,FILE=file_name,IOSTAT=ios,ACTION='WRITE',POSITION='APPEND')
+           endif
+
+           solution_number = solution_number_start
+           do i = 1, zone_col(izn)%num_xycol
+              ii = zone_col(izn)%i_no(i)
+              jj = zone_col(izn)%j_no(i)
+              do kk = zone_col(izn)%kmin_no(i), zone_col(izn)%kmax_no(i)
+                 m = ii + (jj-1)*nx + (kk-1)*nxy
+                 if (frac(m) > 0.0) then
+                    write(fuzf_chem_xyzt,"(4(G20.10,A1), I20, A1, A15, I10)") cnvli*x(ii), &
+                         ACHAR(9),cnvli*y(jj),ACHAR(9),cnvli*z(kk), &
+                         ACHAR(9),current_time,ACHAR(9),solution_number,ACHAR(9), &
+                         "# Fortran cell ",m 
+                    solution_number = solution_number + 1
+                    solution_list(bc_soln_count) = m
+                    bc_soln_count = bc_soln_count + 1
+                 endif
+              end do
+           end do
+           ! write raw solutions to file
+           file_name = trim(file_name_base) // ".soln.bc"
+           CALL write_bc_raw(solution_list, bc_soln_count - 1, solution_number_start, file_name)
+
+           ! finish xyzt file
+           CLOSE(fuzf_chem_xyzt, status='KEEP')
+           solution_number_start = solution_number
+        endif
+     end do
+     CALL write_bc_raw(solution_list, bc_soln_count - 1, 0, file_name)     
+  else
+     do 
+        CALL write_bc_raw(solution_list, bc_soln_count - 1, solution_number_start, file_name)     
+        if (solution_number_start == 0) EXIT
+     enddo
+  endif
+
+  counter = counter + 1
+
+END SUBROUTINE zone_flow_write_chem
+
 !SUBROUTINE subgrid
 !  ! ... Calculates flow rates for each internal zone
 !  USE machine_constants, ONLY: kdp
Index: sumcal1.f90
===================================================================
--- sumcal1.f90	(revision 5000)
+++ sumcal1.f90	(revision 6719)
@@ -43,6 +43,7 @@
   CHARACTER(LEN=130) :: logline1
   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: cavg, sum_cqm_in
   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: qsbc3, qsbc4
+  CHARACTER(LEN=130) error_line
 !!$  REAL(KIND=kdp), DIMENSION(nxy) :: fracn
   ! ... Set string for use with RCS ident command
   CHARACTER(LEN=80) :: ident_string='$Id$'
@@ -171,6 +172,14 @@
         p(m)=p(m)+dp(m)
         ! ... Calculate new pore volumes for confined cells
         pv(m)=pv(m)+pmcv(m)*dp(m)
+        if (pv(m) < 0) then
+            WRITE( error_line, *) "Negative pore volume in transient calculation, cell ", m
+            CALL errprt_c(error_line)
+            WRITE( error_line, *) "Try increasing porosity, decreasing specific storage, or use a free surface." 
+            CALL errprt_c(error_line)
+            ERREXE = .TRUE.  
+            RETURN        
+        endif        
      END IF
 !!$     IF(heat) THEN
 !!$        t(m)=t(m)+dt(m)
Index: print_control_mod.f90
===================================================================
--- print_control_mod.f90	(revision 5000)
+++ print_control_mod.f90	(revision 6719)
@@ -23,11 +23,11 @@
   TYPE (PrintControl) :: &
        print_progress_statistics,  &
        print_components, print_global_flow_balance, print_bc_flows, print_zone_flows, &
-       print_zone_flows_tsv, print_zone_flows_heads, print_wells, &
+       print_zone_flows_tsv, print_zone_flows_xyzt, print_wells, &
        print_conductances, print_heads, print_velocities, print_force_chemistry, &
        print_hdf_chemistry, print_xyz_components, print_hdf_heads, print_hdf_velocities, &
        print_xyz_chemistry, print_xyz_heads, print_xyz_velocities, print_xyz_wells, &
-       print_restart, print_restart_hst
+       print_restart, print_restart_hst, print_hdf_intermediate
 
   LOGICAL :: print_end_of_period
   DOUBLE PRECISION ::next_print_time
@@ -52,6 +52,7 @@
     CALL pc_init(print_components, .FALSE., "print_components")
     CALL pc_init(print_force_chemistry, .FALSE., "print_force_chemistry")
     CALL pc_init(print_hdf_chemistry, .FALSE., "print_hdf_chemistry")
+    CALL pc_init(print_hdf_intermediate, .FALSE., "print_hdf_intermediate")
     CALL pc_init(print_xyz_components, .FALSE., "print_xyz_components")
     CALL pc_init(print_xyz_chemistry, .FALSE., "print_xyz_chemistry")
     CALL pc_init(print_restart, .FALSE., "print_restart")
@@ -61,7 +62,7 @@
     CALL pc_init(print_bc_flows, .FALSE., "print_bc_flows")
     CALL pc_init(print_zone_flows, .FALSE., "print_zone_flows")
     CALL pc_init(print_zone_flows_tsv, .FALSE., "print_zone_flows_tsv")
-    CALL pc_init(print_zone_flows_heads, .FALSE., "print_zone_flows_heads")
+    CALL pc_init(print_zone_flows_xyzt, .FALSE., "print_zone_flows_xyzt")
     CALL pc_init(print_conductances, .FALSE., "print_conductances")
     CALL pc_init(print_heads, .TRUE., "print_heads")
     CALL pc_init(print_velocities, .TRUE., "print_velocities")
@@ -134,7 +135,7 @@
     CALL pc_set_print_flag(print_bc_flows, utime, itime, utimchg)
     CALL pc_set_print_flag(print_zone_flows, utime, itime, utimchg)
     CALL pc_set_print_flag(print_zone_flows_tsv, utime, itime, utimchg)
-    CALL pc_set_print_flag(print_zone_flows_heads, utime, itime, utimchg)
+    CALL pc_set_print_flag(print_zone_flows_xyzt, utime, itime, utimchg)
     CALL pc_set_print_flag(print_wells, utime, itime, utimchg)
     CALL pc_set_print_flag(print_conductances, utime, itime, utimchg)
     IF(itime == 1 .AND. prt_kd) THEN
@@ -146,6 +147,7 @@
     CALL pc_set_print_flag(print_velocities, utime, itime, utimchg)
     CALL pc_set_print_flag(print_force_chemistry, utime, itime, utimchg)
     CALL pc_set_print_flag(print_hdf_chemistry, utime, itime, utimchg)
+    CALL pc_set_print_flag(print_hdf_intermediate, utime, itime, utimchg)
     CALL pc_set_print_flag(print_xyz_components, utime, itime, utimchg)
     CALL pc_set_print_flag(print_hdf_heads, utime, itime, utimchg)
     CALL pc_set_print_flag(print_hdf_velocities, utime, itime, utimchg)
@@ -224,10 +226,10 @@
     timprzf_tsv = print_zone_flows_tsv%print_time
     ntprzf_tsv = print_zone_flows_tsv%count_prints
     
-    przf_heads = print_zone_flows_heads%print_flag
-    pri_zf_heads = print_zone_flows_heads%print_interval
-    timprzf_heads = print_zone_flows_heads%print_time
-    ntprzf_heads = print_zone_flows_heads%count_prints 
+    przf_xyzt = print_zone_flows_xyzt%print_flag
+    pri_zf_xyzt = print_zone_flows_xyzt%print_interval
+    timprzf_xyzt = print_zone_flows_xyzt%print_time
+    ntprzf_xyzt = print_zone_flows_xyzt%count_prints 
     
     przf = print_zone_flows%print_flag
     pri_zf = print_zone_flows%print_interval
@@ -292,6 +294,11 @@
     timprhdfcph = print_hdf_chemistry%print_time
     prhdfci = print_hdf_chemistry%print_flag_integer
 
+    prhdfi = print_hdf_intermediate%print_flag
+    prihdf_intermediate = print_hdf_intermediate%print_interval
+    timprhdfi = print_hdf_intermediate%print_time
+    prhdfii = print_hdf_intermediate%print_flag_integer
+
     prhdfh = print_hdf_heads%print_flag
     prihdf_head = print_hdf_heads%print_interval
     timprhdfh = print_hdf_heads%print_time
@@ -344,10 +351,10 @@
     print_zone_flows_tsv%print_time = timprzf_tsv
     print_zone_flows_tsv%count_prints = ntprzf_tsv
     
-    print_zone_flows_heads%print_flag = przf_heads
-    print_zone_flows_heads%print_interval = pri_zf_heads
-    print_zone_flows_heads%print_time = timprzf_heads
-    print_zone_flows_heads%count_prints = ntprzf_heads    
+    print_zone_flows_xyzt%print_flag = przf_xyzt
+    print_zone_flows_xyzt%print_interval = pri_zf_xyzt
+    print_zone_flows_xyzt%print_time = timprzf_xyzt
+    print_zone_flows_xyzt%count_prints = ntprzf_xyzt    
 
     print_bc_flows%print_flag = prbcf
     print_bc_flows%print_interval = pribcf
@@ -407,6 +414,11 @@
     print_hdf_chemistry%print_time = timprhdfcph
     print_hdf_chemistry%print_flag_integer = prhdfci
 
+    print_hdf_intermediate%print_flag = prhdfi
+    print_hdf_intermediate%print_interval = prihdf_intermediate
+    print_hdf_intermediate%print_time = timprhdfi
+    print_hdf_intermediate%print_flag_integer = prhdfii
+
     print_hdf_heads%print_flag = prhdfh
     print_hdf_heads%print_interval = prihdf_head
     print_hdf_heads%print_time = timprhdfh
@@ -447,7 +459,7 @@
     CALL pc_set_print_time(print_global_flow_balance, utime)
     CALL pc_set_print_time(print_zone_flows, utime)
     CALL pc_set_print_time(print_zone_flows_tsv, utime)
-    CALL pc_set_print_time(print_zone_flows_heads, utime)
+    CALL pc_set_print_time(print_zone_flows_xyzt, utime)
     CALL pc_set_print_time(print_bc_flows, utime)
     CALL pc_set_print_time(print_wells, utime)
     CALL pc_set_print_time(print_conductances, utime)
@@ -455,6 +467,7 @@
     CALL pc_set_print_time(print_velocities, utime)
     CALL pc_set_print_time(print_force_chemistry, utime)
     CALL pc_set_print_time(print_hdf_chemistry, utime)
+    CALL pc_set_print_time(print_hdf_intermediate, utime)
     CALL pc_set_print_time(print_xyz_components, utime)
     CALL pc_set_print_time(print_hdf_heads, utime)
     CALL pc_set_print_time(print_hdf_velocities, utime)
@@ -493,7 +506,7 @@
     CALL pc_update_print_time(print_global_flow_balance, utime)
     CALL pc_update_print_time(print_zone_flows, utime)
     CALL pc_update_print_time(print_zone_flows_tsv, utime)
-    CALL pc_update_print_time(print_zone_flows_heads, utime)
+    CALL pc_update_print_time(print_zone_flows_xyzt, utime)
     CALL pc_update_print_time(print_bc_flows, utime)
     CALL pc_update_print_time(print_wells, utime)
     CALL pc_update_print_time(print_conductances, utime)
@@ -501,6 +514,7 @@
     CALL pc_update_print_time(print_velocities, utime)
     CALL pc_update_print_time(print_force_chemistry, utime)
     CALL pc_update_print_time(print_hdf_chemistry, utime)
+    CALL pc_update_print_time(print_hdf_intermediate, utime)
     CALL pc_update_print_time(print_xyz_components, utime)
     CALL pc_update_print_time(print_hdf_heads, utime)
     CALL pc_update_print_time(print_hdf_velocities, utime)
@@ -540,7 +554,7 @@
     CALL pc_dump(print_global_flow_balance)
     CALL pc_dump(print_zone_flows)
     CALL pc_dump(print_zone_flows_tsv)
-    CALL pc_dump(print_zone_flows_heads)
+    CALL pc_dump(print_zone_flows_xyzt)
     CALL pc_dump(print_bc_flows)
     CALL pc_dump(print_wells)
     CALL pc_dump(print_conductances)
@@ -548,6 +562,7 @@
     CALL pc_dump(print_velocities)
     CALL pc_dump(print_force_chemistry)
     CALL pc_dump(print_hdf_chemistry)
+    CALL pc_dump(print_hdf_intermediate)
     CALL pc_dump(print_xyz_components)
     CALL pc_dump(print_hdf_heads)
     CALL pc_dump(print_hdf_velocities)
Index: hdf_f.f90
===================================================================
--- hdf_f.f90	(revision 5000)
+++ hdf_f.f90	(revision 6719)
@@ -186,3 +186,15 @@
   CALL HDF_CLOSE_TIME_STEP()  
 END SUBROUTINE hdf_end_time_step
 
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! TODO
+!
+! Preconditions:
+!   TODO
+! Postconditions:
+!   TODO
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+SUBROUTINE write_hdf_intermediate()
+  IMPLICIT NONE
+  CALL HDF_INTERMEDIATE()  
+END SUBROUTINE write_hdf_intermediate
Index: hst.h
===================================================================
--- hst.h	(revision 5000)
+++ hst.h	(revision 6719)
@@ -50,7 +50,7 @@
 /*
  *  Used to reduce dimension of problem for phreeqc
  */
-EXTERNAL int *forward;
+EXTERNAL int *forward1;
 EXTERNAL struct back_list *back;
 EXTERNAL int count_back_list;
 EXTERNAL int ix, iy, iz;
Index: read2.f90
===================================================================
--- read2.f90	(revision 5000)
+++ read2.f90	(revision 6719)
@@ -54,6 +54,7 @@
   INTEGER, DIMENSION(:), ALLOCATABLE :: uzmbc
   REAL(KIND=kdp), DIMENSION(:), ALLOCATABLE :: uabc, ubbbc, ukbc, uzebc
   CHARACTER(LEN=130) :: logline1, logline2
+  INTEGER :: ii
   ! ... set string for use with rcs ident command
   CHARACTER(LEN=80) :: ident_string='$Id$'
   !     ------------------------------------------------------------------
@@ -874,6 +875,7 @@
   ! set integer flags
   prhdfci = 0
   IF (prtichdf_conc) prhdfci = 1
+  prhdfii = 0
   prhdfhi = 0
   IF (prtichdf_head) prhdfhi = 1
   prhdfvi = 0
@@ -924,10 +926,10 @@
   ENDIF
   ! ... Internal zones for flow rate tabulation
   READ(fuins,*) num_flo_zones
-  IF (print_rde) WRITE(furde, 8011) 'num_flow_zones,[2.23.8]', num_flo_zones
+  IF (print_rde) WRITE(furde, "(tr5,a/tr5,i8)") 'num_flow_zones,[2.23.8]', num_flo_zones
   IF(num_flo_zones > 0) THEN
      ! ... Allocate space for internal boundary zone data
-     ALLOCATE (zone_title(num_flo_zones),  &
+     ALLOCATE (zone_title(num_flo_zones), zone_number(num_flo_zones), &
           zone_ib(num_flo_zones), lnk_bc2zon(num_flo_zones,4),  &
           seg_well(num_flo_zones),  &
           zone_filename_heads(num_flo_zones),  &
@@ -957,37 +959,51 @@
         izn = izn+1
         IF (print_rde) WRITE(furde,8015) '** Flow Zone No.',izn,' **'
 8015    FORMAT(tr25,a,i3,a)
-        READ(line,'(a)') zone_title(izn)
-        IF (print_rde) WRITE(furde,'(tr5,a)') zone_title(izn)
+        line = adjustl(line)
+        ii = INDEX(line, ' ', .false.)
+        !READ(line,'(i, a)') zone_number(izn), zone_title(izn)
+        READ(line(1:ii),'(i)') zone_number(izn)
+        READ(line(ii+1:), '(a)') zone_title(izn)
+        IF (print_rde) WRITE(furde,'(tr5,i,a)') zone_number(izn), zone_title(izn)
         READ(fuins,*) zone_write_heads(izn)
-        if(zone_write_heads(izn)) READ(fuins,'(a)') zone_filename_heads(izn)
-        IF (print_rde) WRITE(furde,'(tr5,l2,a)') zone_write_heads(izn), zone_filename_heads(izn)
-        zone_filename_heads(izn) = ADJUSTL(zone_filename_heads(izn))
+        
+        IF(zone_write_heads(izn)) THEN
+            READ(fuins,'(a)') zone_filename_heads(izn)
+            IF (print_rde) WRITE(furde,'(tr5,l2,a)') zone_write_heads(izn), zone_filename_heads(izn)
+            zone_filename_heads(izn) = ADJUSTL(zone_filename_heads(izn))
+        ELSE
+            IF (print_rde) WRITE(furde,'(tr5,l2)') zone_write_heads(izn)
+        ENDIF
 
         IF((fresur .AND. (nfbc > 0 .OR. nrbc > 0)) .OR. zone_write_heads(izn)) THEN
            IF (print_rde) WRITE(furde,8005) '** Flow Zone Volume Parameters **',  &
                 '  (read echo[2.23.10])',' i_no   j_no   kmin_no   kmax_no'
            READ(fuins,*) zone_col(izn)%num_xycol
-           ALLOCATE (zone_col(izn)%i_no(zone_col(izn)%num_xycol),  &
-                zone_col(izn)%j_no(zone_col(izn)%num_xycol),  &
-                zone_col(izn)%kmin_no(zone_col(izn)%num_xycol),  &
-                zone_col(izn)%kmax_no(zone_col(izn)%num_xycol),  &
-                stat = a_err)
-           IF (a_err /= 0) THEN
-              PRINT *, "array allocation failed: read2, flow zones.23.11"
-              STOP
+           IF (print_rde) WRITE(furde,'(tr5,i8)') zone_col(izn)%num_xycol
+           IF (zone_col(izn)%num_xycol > 0) THEN
+               ALLOCATE (zone_col(izn)%i_no(zone_col(izn)%num_xycol),  &
+                    zone_col(izn)%j_no(zone_col(izn)%num_xycol),  &
+                    zone_col(izn)%kmin_no(zone_col(izn)%num_xycol),  &
+                    zone_col(izn)%kmax_no(zone_col(izn)%num_xycol),  &
+                    stat = a_err)
+               IF (a_err /= 0) THEN
+                  PRINT *, "array allocation failed: read2, flow zones.23.11"
+                  STOP
+               ENDIF
+
+               READ(fuins,*) (zone_col(izn)%i_no(icol), zone_col(izn)%j_no(icol),  &
+                    zone_col(izn)%kmin_no(icol), zone_col(izn)%kmax_no(icol),  &
+                    icol=1,zone_col(izn)%num_xycol)
+               IF (print_rde) WRITE(furde,8223) (zone_col(izn)%i_no(icol), zone_col(izn)%j_no(icol),  &
+                    zone_col(izn)%kmin_no(icol), zone_col(izn)%kmax_no(icol),  &
+                    icol=1,zone_col(izn)%num_xycol)
+    8223       FORMAT(tr5,4i6)
            ENDIF
-           READ(fuins,*) (zone_col(izn)%i_no(icol), zone_col(izn)%j_no(icol),  &
-                zone_col(izn)%kmin_no(icol), zone_col(izn)%kmax_no(icol),  &
-                icol=1,zone_col(izn)%num_xycol)
-           IF (print_rde) WRITE(furde,8223) (zone_col(izn)%i_no(icol), zone_col(izn)%j_no(icol),  &
-                zone_col(izn)%kmin_no(icol), zone_col(izn)%kmax_no(icol),  &
-                icol=1,zone_col(izn)%num_xycol)
-8223       FORMAT(tr5,4i6)
         END IF
         IF (print_rde) WRITE(furde,8005) '** Flow Zone Face Parameters **',  &
              '  (read echo[2.23.13])',' cell_no    face index'
         READ(fuins,*) zone_ib(izn)%num_int_faces
+        IF (print_rde) WRITE(furde,'(tr5,i8)') zone_ib(izn)%num_int_faces
         IF(zone_ib(izn)%num_int_faces > 0) THEN
            ALLOCATE (zone_ib(izn)%mcell_no(zone_ib(izn)%num_int_faces),  &
                 zone_ib(izn)%face_indx(zone_ib(izn)%num_int_faces),  &
@@ -1000,7 +1016,7 @@
            READ(fuins,*) (uzmic(ifc), uziface(ifc), ifc=1,zone_ib(izn)%num_int_faces)
            IF (print_rde) WRITE(furde,8213) (uzmic(ifc), uziface(ifc),  &
                 ifc=1,zone_ib(izn)%num_int_faces)
-8213       FORMAT(tr1,10i6)
+8213       FORMAT(tr1,10i8)
            zone_ib(izn)%mcell_no(:) = uzmic(:)
            zone_ib(izn)%face_indx(:) = uziface(:)
            DEALLOCATE(uzmic, uziface,  &
Index: init2_post_ss.f90
===================================================================
--- init2_post_ss.f90	(revision 5000)
+++ init2_post_ss.f90	(revision 6719)
@@ -15,6 +15,7 @@
   REAL(KIND=kdp) :: viscos  
   REAL(KIND=kdp) :: time_phreeqc, u0, u1, uc, ut
   INTEGER :: imod, iis, iwel, k, l, m, mt, nr, nsa
+  CHARACTER(LEN=130) error_line
 !!$  LOGICAL :: erflg
   ! ... Set string for use with RCS ident command
   CHARACTER(LEN=80) :: ident_string='$Id$'
@@ -179,12 +180,20 @@
   END DO
   frac_icchem = frac
   DO m = 1, nxyz  
-     IF(.NOT.fresur) THEN
-        pv(m) = pv(m) + pmcv(m)*(p(m)-p0)
-     ELSEIF(m <= nxyz-nxy) THEN
-        IF(ABS(frac(m) - 1._kdp) <= 1.e-6_kdp .AND. frac(m+nxy) > 0.)  &
-             pv(m) = pv(m) + pmcv(m)*(p(m)-p0)
-     ENDIF
+!     IF(.NOT.fresur) THEN
+!        pv(m) = pv(m) + pmcv(m)*(p(m)-p0)
+!     ELSEIF(m <= nxyz-nxy) THEN
+!        IF(ABS(frac(m) - 1._kdp) <= 1.e-6_kdp .AND. frac(m+nxy) > 0.)  &
+!             pv(m) = pv(m) + pmcv(m)*(p(m)-p0)
+!     ENDIF
+     if (pv(m) < 0) then
+        WRITE( error_line, *) "Negative pore volume after steady-state calculation, cell ", m
+        CALL errprt_c(error_line)
+        WRITE( error_line, *) "Increase porosity, decrease specific storage, or use free surface boundary."
+        CALL errprt_c(error_line)
+        ERREXE = .TRUE.  
+        RETURN        
+     endif
      ! ... Initial fluid(kg), heat(j), solute(kg) and pore volume(m^3)
      ! ...      in the region
      u0 = pv(m)*frac(m)  
Index: phast_main.cpp
===================================================================
--- phast_main.cpp	(revision 5000)
+++ phast_main.cpp	(revision 6719)
@@ -14,6 +14,46 @@
 
 extern "C" void PHAST_SUB(int *mpi_tasks, int *mpi_myself);
 
+#if WIN32
+#include <windows.h>
+#include "phrqtype.h"
+
+extern "C" void HDF_Finalize(void);
+int write_restart(double hst_time);
+
+extern LDBLE rate_sim_time_end;
+extern LDBLE rate_cnvtmi;
+
+BOOL CtrlHandler(DWORD dwCtrlType)
+{
+	try
+	{
+		switch(dwCtrlType)
+		{
+		case CTRL_LOGOFF_EVENT:
+			break;
+		case CTRL_C_EVENT:
+		case CTRL_CLOSE_EVENT:
+		case CTRL_BREAK_EVENT:
+		case CTRL_SHUTDOWN_EVENT:
+			OutputDebugString("CtrlHandler Catch\n");
+			HDF_Finalize();
+			write_restart(rate_sim_time_end * rate_cnvtmi);
+			ExitProcess(1);
+			return TRUE;
+		default:
+			break;
+		}
+	}
+	catch(...)
+	{
+		ExitProcess(1);
+	}
+	return FALSE;
+}
+#endif
+
+
 int main(int argc, char* argv[])
 {
 	int mpi_tasks;
@@ -38,6 +78,11 @@
 	mpi_tasks = 1;
 	mpi_myself = 0;
 #endif
+
+#if WIN32
+	SetConsoleCtrlHandler((PHANDLER_ROUTINE) CtrlHandler, TRUE);
+#endif
+
 	PHAST_SUB(&mpi_tasks, &mpi_myself);
 	return EXIT_SUCCESS;
 }
Index: cxxHstSubs.cxx
===================================================================
--- cxxHstSubs.cxx	(revision 5000)
+++ cxxHstSubs.cxx	(revision 6719)
@@ -249,7 +249,7 @@
 	int i, j;
 	for (i = 0; i < ixyz; i++)
 	{
-		j = forward[i];
+		j = forward1[i];
 		if (j < 0)
 			continue;
 		hst_to_buffer(&fraction[i], *dim);
Index: phast_root.F90
===================================================================
--- phast_root.F90	(revision 5000)
+++ phast_root.F90	(revision 6719)
@@ -42,8 +42,13 @@
   ! ... Read the time invariant data
      CALL read2
      CALL init2_1
+     ! geometric pv
+     pv0 = pv     
      CALL init2_2
-     pv0 = pv
+     if (.NOT.steady_flow) then
+        ! pressure corrected pv
+        pv0 = pv
+     endif
      CALL error2
 !     time_phreeqc = 0.d0 
      time_phreeqc = time
@@ -82,7 +87,16 @@
 !
 !  Calculate steady flow
 !
-  IF(steady_flow) CALL simulate_ss_flow  ! ... Solve flow equation to steady state to obtain i.c.
+  IF(steady_flow) THEN 
+    CALL simulate_ss_flow  ! ... Solve flow equation to steady state to obtain i.c.
+    !if (abs(pri_zf_xyzt) > 0) then
+    !    CALL zone_flow_write_heads
+    !    ntprzf_xyzt = ntprzf_xyzt+1
+    !endif
+  ENDIF
+
+  CALL zone_flow_write_heads
+
   IF(errexe .OR. errexi) GO TO 50
 !
 !  Initial equilibrate
@@ -102,7 +116,10 @@
      CALL equilibrate(c,nxyz,prcphrqi,x_node,y_node,z_node,time_phreeqc,deltim_dummy,prslmi,  &
            cnvtmi,frac_icchem,iprint_chem,iprint_xyz, &
            prf_chem_phrqi,stop_msg,prhdfci,rebalance_fraction_f, &
-           print_restart_flag, pv, pv0, steady_flow, volume)
+           print_restart_flag, pv, pv0, steady_flow, volume, przf_xyzt)
+           !if (steady_flow .and. abs(pri_zf_xyzt) > 0) then
+             CALL zone_flow_write_chem(mpi_tasks, mpi_myself, .true.)
+           !endif
      CALL init2_3
   ENDIF
 !
@@ -135,6 +152,11 @@
         do while(time*one_plus_eps >= timchg)
         ! IF (time*one_plus_eps >= timchg) THEN
            CALL read3
+           !if (ntprzf_xyzt .eq. 0 .and. abs(pri_zf_xyzt) > 0) then
+           !     CALL zone_flow_write_heads
+           !     CALL zone_flow_write_chem(mpi_tasks, mpi_myself, .true.)
+           !     ntprzf_xyzt = ntprzf_xyzt+1
+           ! endif
            IF(thru) EXIT      ! ... Normal exit from time step loop
            CALL init3
            CALL error3
@@ -174,13 +196,20 @@
            CALL screenprt_c(logline1)
            CALL equilibrate(c,nxyz,prcphrqi,x_node,y_node,z_node,time,deltim,prslmi,cnvtmi,  &
                 frac,iprint_chem,iprint_xyz,prf_chem_phrqi,stop_msg,prhdfci,rebalance_fraction_f, &
-                print_restart%print_flag_integer, pv, pv0, steady_flow, volume)
+                print_restart%print_flag_integer, pv, pv0, steady_flow, volume, przf_xyzt)
         ENDIF
         CALL sumcal2
         CALL write5
+        IF(przf_xyzt .AND. .NOT.steady_flow) THEN  
+            CALL zone_flow_write_heads
+        ENDIF
+        CALL zone_flow_write_chem(mpi_tasks, mpi_myself, .false.)
         CALL write4                      ! ... Calculate and print velocity fields if requested
 #if defined(HDF5_CREATE)
         CALL hdf_end_time_step
+        IF (prhdfii) THEN
+           CALL write_hdf_intermediate     
+        ENDIF
 #endif
         CALL update_print_flags          ! ... Update times for next printouts
         IF(errexe) EXIT
Index: merge.c
===================================================================
--- merge.c	(revision 5000)
+++ merge.c	(revision 6719)
@@ -7,10 +7,11 @@
 #include <mpi.h>				/* MPI routines */
 #include <hdf5.h>				/* HDF routines */
 #include <stdarg.h>				/* va_start va_list va_end */
-#define MPI_MAX_TASKS 50		/* from hst.c */
+//#define MPI_MAX_TASKS 50		/* from hst.c */
 
 #define EXTERNAL extern
 #define USE_DEFAULT_FPRINTF
+#include <vector>
 #include "phreeqc/global.h"		/* error_string */
 #include "hst.h"				/* struct back_list */
 #include "phreeqc/phqalloc.h"	/* PHRQ_malloc PHRQ_realloc PHRQ_free */
@@ -116,7 +117,9 @@
 FileInfo_merge(struct FileInfo *ptr_info, hid_t xfer_pid, hid_t mem_dspace,
 			   int *cell_to_proc)
 {
-	extern int end_cells[MPI_MAX_TASKS][2];
+	//extern int end_cells[MPI_MAX_TASKS][2];
+	extern std::vector<int> start_cell;
+	extern std::vector<int> end_cell;
 	extern int mpi_myself;
 	extern int count_chem;
 	extern int mpi_tasks;
@@ -135,7 +138,8 @@
 
 	/* allocate space */
 	local_count_chem =
-		end_cells[mpi_myself][1] - end_cells[mpi_myself][0] + 1;
+		//end_cells[mpi_myself][1] - end_cells[mpi_myself][0] + 1;
+		end_cell[mpi_myself] - start_cell[mpi_myself] + 1;
 	local_record_size_array = NULL;
 	local_record_size_buffer = NULL;
 	root_record_size_array = NULL;
@@ -526,7 +530,9 @@
 void
 MergeBeginTimeStep(int print_sel, int print_out)
 {
-	extern int end_cells[MPI_MAX_TASKS][2];
+	//extern int end_cells[MPI_MAX_TASKS][2];
+	extern std::vector<int> start_cell;
+	extern std::vector<int> end_cell;
 	extern int *random_list;
 	extern int mpi_myself;
 
@@ -566,8 +572,10 @@
 	}
 
 	/* determine space */
-	ptr_beg = &(random_list[end_cells[mpi_myself][0]]);
-	ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+	//ptr_beg = &(random_list[end_cells[mpi_myself][0]]);
+	ptr_beg = &(random_list[start_cell[mpi_myself]]);
+	//ptr_end = &(random_list[end_cells[mpi_myself][1]]);
+	ptr_end = &(random_list[end_cell[mpi_myself]]);
 	dims[0] = ptr_end - ptr_beg + 1;
 
 	/* create the dataspace */
@@ -615,7 +623,9 @@
 	extern int mpi_myself;
 	extern int mpi_tasks;
 
-	extern int end_cells[MPI_MAX_TASKS][2];
+	//extern int end_cells[MPI_MAX_TASKS][2];
+	extern std::vector<int> start_cell;
+	extern std::vector<int> end_cell;
 	extern int *random_list;
 
 	int *cell_to_proc;
@@ -633,7 +643,8 @@
 		malloc_error();
 	for (task_number = 0; task_number < mpi_tasks; ++task_number)
 	{
-		for (k = end_cells[task_number][0]; k <= end_cells[task_number][1];
+		//for (k = end_cells[task_number][0]; k <= end_cells[task_number][1];
+		for (k = start_cell[task_number]; k <= end_cell[task_number];
 			++k)
 		{
 			cell_to_proc[random_list[k]] = task_number;
Index: init2_2.f90
===================================================================
--- init2_2.f90	(revision 5000)
+++ init2_2.f90	(revision 6719)
@@ -140,7 +140,7 @@
   ntprgfb = 0
   ntprzf = 0
   ntprzf_tsv = 0
-  ntprzf_heads = 0
+  ntprzf_xyzt = 0
   ntprkd = 0
   ntprmapcomp = 0
   ntprmaphead = 0
Index: error3.f90
===================================================================
--- error3.f90	(revision 5000)
+++ error3.f90	(revision 6719)
@@ -114,10 +114,11 @@
   IF(pri_well_timser > 0._kdp .AND. pri_well_timser < udeltim) warnflag = warnflag + 1
   IF(pri_zf > 0._kdp .AND. pri_zf < udeltim) warnflag = warnflag + 1
   IF(pri_zf_tsv > 0._kdp .AND. pri_zf_tsv < udeltim) warnflag = warnflag + 1
-  IF(pri_zf_heads > 0._kdp .AND. pri_zf_heads < udeltim) warnflag = warnflag + 1
+  IF(pri_zf_xyzt > 0._kdp .AND. pri_zf_xyzt < udeltim) warnflag = warnflag + 1
   IF(prihdf_head > 0._kdp .AND. prihdf_head < udeltim) warnflag = warnflag + 1
   IF(prihdf_vel > 0._kdp .AND. prihdf_vel < udeltim) warnflag = warnflag + 1
   IF(prihdf_conc > 0._kdp .AND. prihdf_conc < udeltim) warnflag = warnflag + 1
+  IF(prihdf_intermediate > 0._kdp .AND. prihdf_intermediate < udeltim) warnflag = warnflag + 1
   IF(warnflag > 0) THEN
      WRITE(logline1,'(i2,a)') warnflag,' print control intervals are less than '//  &
           'defined time step length.'
Index: write5.f90
===================================================================
--- write5.f90	(revision 5000)
+++ write5.f90	(revision 6719)
@@ -59,7 +59,7 @@
      prbcf=.TRUE.
      przf = .TRUE.
      przf_tsv = .TRUE.
-     przf_heads = .TRUE.
+     przf_xyzt = .TRUE.
      IF(nwel > 0) prwel=.TRUE.
      prslm=.TRUE.
   END IF
@@ -175,7 +175,7 @@
            DO  m=1,nxyz
               aprnt1(m)=c_mol(m,is)
            END DO
-           CALL prntar(2,aprnt1,lprnt1,fuc,cnv,25,000)
+           CALL prntar(2,aprnt1,lprnt1,fuc,cnv,24,000)
         END DO
         ntprc = ntprc+1
      END IF
@@ -394,7 +394,7 @@
      WRITE(fuzf,2001)  '*** Output at End of Time Step No. ', itime,' ***'
      WRITE(fuzf,2002) 'Time '//dots,cnvtmi*time,'('//TRIM(unittm)//')'
      DO izn=1,num_flo_zones
-        WRITE(fuzf,2310) '*** Zonal Flow Summary, zone:',izn,' ***',  &
+        WRITE(fuzf,2310) '*** Zonal Flow Summary, zone:',zone_number(izn),' ***',  &
              zone_title(izn), 'Current Time Step','Rates'
 2310    FORMAT(/tr40,a,i4,a,/tr10,a/tr25,a,tr25,a)
         WRITE(fuzf,2311) 'Fluid inflow '//dots,cnvmfi*qfzoni(izn),  &
@@ -485,7 +485,7 @@
   IF(przf_tsv) THEN  
      ! ... Zonal flow rates to tab separated file, fuzf_tsv
      DO izn=1,num_flo_zones
-        WRITE(fuzf_tsv,2502) cnvtmi*time,ACHAR(9),izn,ACHAR(9),'Water',ACHAR(9),  &
+        WRITE(fuzf_tsv,2502) cnvtmi*time,ACHAR(9),zone_number(izn),ACHAR(9),'Water',ACHAR(9),  &
              cnvmfi*qfzoni(izn),ACHAR(9),cnvmfi*qfzonp(izn),ACHAR(9),  &
              cnvmfi*qfzoni_int(izn),ACHAR(9),cnvmfi*qfzonp_int(izn),ACHAR(9),  &
              cnvmfi*qfzoni_sbc(izn),ACHAR(9),cnvmfi*qfzonp_sbc(izn),ACHAR(9),  &
@@ -497,7 +497,7 @@
 2502    FORMAT(tr1,1pg13.6,a,i3,a,a,a,16(1pg14.7,a))
         IF (solute) THEN
            DO  is=1,ns-1                             ! ... No printout of charge flows
-              WRITE(fuzf_tsv,2502) cnvtmi*time,ACHAR(9),izn,ACHAR(9),comp_name(is),ACHAR(9),  &
+              WRITE(fuzf_tsv,2502) cnvtmi*time,ACHAR(9),zone_number(izn),ACHAR(9),comp_name(is),ACHAR(9),  &
                    cnvmfi*qszoni(is,izn),ACHAR(9),cnvmfi*qszonp(is,izn),ACHAR(9),  &
                    cnvmfi*qszoni_int(is,izn),ACHAR(9),cnvmfi*qszonp_int(is,izn),ACHAR(9),  &
                    cnvmfi*qszoni_sbc(is,izn),ACHAR(9),cnvmfi*qszonp_sbc(is,izn),ACHAR(9),  &
@@ -511,11 +511,16 @@
      ENDDO
      ntprzf_tsv = ntprzf_tsv+1
   END IF
-  IF(przf_heads) THEN  
-     ! ... Zonal heads to file, fuzf_heads
-     CALL zone_flow_write_heads
-     ntprzf_heads = ntprzf_heads+1
-  END IF
+  !IF(przf_xyzt .AND. .NOT.steady_flow) THEN  
+  !   ! ... Zonal heads to file, fuzf_heads
+  !   CALL zone_flow_write_heads
+  !   ntprzf_xyzt = ntprzf_xyzt+1
+  !END IF
+  ! move to phast_root and phast_slave
+  !IF(przf_xyzt .and. solute) THEN  
+  !   ! ... Zonal chem to file, fuzf_chem_xyzt and chem.bc
+  !   CALL zone_flow_write_chem
+  !END IF
   IF(prwel .OR. prtem) THEN
      nsa = MAX(ns,1)
      ALLOCATE (chu10a(nsa), chu11a(nsa), cwkt_mol(nwel,nsa), &
